;32-bit Virtual Machine and application ROM for 8051, flavor SiLabs EFM8LB1.
;Code generated by Tiff using template.A51 -- don't edit this file.

;The VM model interfaces with Keil C51 C functions, which use R4R5R6R7 as the
;return value as well as the _long_ non-pointer first parameter.
;The first pointer parameter is R2R1R0.

$NOMOD51
#include "SI_EFM8LB1_Defs.inc"
XRAMsize    EQU 1000H                  ;XRAM size of MCU in bytes

;The VM's USER function is free to trash the registers since it's the last
;executed slot. Otherwise, the VM uses R0-R3 as scratchpad.
;The RAM (with RAMsize 32-bit words) is implemented in XRAM.
;XRAMsize is used to place the VM's RAM at the top of XRAM. The linker will see it.

ROMsize     EQU 474 ;longs in ROM (at end of this file)

;-------------------------------------------------------------------------------
;The Keil C51/A51 compiler (assembled code/data) is big endian.
;The VM (code, stack and data space) is little endian.
;IRAM data is big endian, XRAM (and all other) data is little endian.

            NAME VMstuff

            PUBLIC _VM                  ;uint32_t VM(uint32_t IR);
            PUBLIC VMpor                ;void VMpor(void);

ExtFnTable  EQU 0x00A0

;Absolute XDATA is used for the RAM of the VM.
            XSEG AT XRAMsize - (4*512)
RAM:        DS 4*512
;Size is assumed to be a power-of-2 multiple of 256-byte pages in size.
;This allows a byte-wide bit mask to wrap the RAM address.
RAMpage:    EQU 512/256


?ID?VM      SEGMENT DATA                ;Direct RAM
?BI?VM      SEGMENT BIT                 ;Bit space
?PR?VM      SEGMENT CODE                ;Code space

            RSEG ?ID?VM

T:          DS 4                        ;top of stack
N:          DS 4                        ;next on stack
PC:         DS 4                        ;program counter
DebugReg:   DS 4
IR:         DS 4                        ;instruction register
RP:         DS 2                        ;return stack pointer = 64
SP:         DS 2                        ;return stack pointer = 32
UP:         DS 2                        ;return stack pointer = 64
Scratch:    DS 7                        ;scratchpad storage
Temp:       DS 1                        ;more scratchpad
NEXTSLOT:   DS 1

            RSEG ?BI?VM
CARRY:      DS 1                        ;carry flag

;-------------------------------------------------------------------------------

            RSEG ?PR?VM
            USING 0
VMinitTable:
            DW RAM+64, RAM+32, RAM+64   ;registers for VM

VMpor:      MOV R0, #T                  ;-> first Direct RAM
            MOV R1, #16
            CLR A
VMpor0:         MOV @R0, A              ;clear first 4 longs
                INC R0
                DJNZ R1, VMpor0
            MOV DPTR, #VMinitTable
            MOV R1, #6
VMpor1:         CLR A                   ;load 3 halfwords from table
                MOVC A, @A+DPTR
                INC DPTR
                MOV @R0, A
                INC R0
                DJNZ R1, VMpor1
            MOV DPTR, #RAM              ;clear all of RAM
            MOV R2, #AddrMask+1
            CLR A
VMpor2:         MOVX @DPTR, A           ;clear page
                DJNZ R1, VMpor1
                DJNZ R2, VMpor1
            RET

;-------------------------------------------------------------------------------

;uint32_t VM(uint32_t IR); IR is in r4r5r6r7. For speed, unwind short loops.
            MOV IR, R4                  ;get IR
            MOV IR+1, R5
            MOV IR+2, R6
            MOV IR+3, R7
            MOV R4, T
            MOV R5, T+1
            MOV R6, T+2
            MOV R7, T+3
            INC PC+3                    ;PC++
            JNC NEXT
            INC PC+2
            JNC NEXT
            INC PC+1
            JNC NEXT
            INC PC
            MOV NEXTSLOT, #0
NEXT:	    MOV DPTR, #SLOT0
            MOV A, NEXTSLOT
            JMP @A+DPTR
SLOT0:      MOV A, IR
            RRC A
            RRC A
            MOV NEXTSLOT, #SLOT1-SLOT0
            SJMP DISPATCH
SLOT1:      MOV A, IR1
            SWAP A
            ANL A, #0FH
            MOV R0, A
            MOV A, IR0
            SWAP A
            ANL A, #30H
            ORL A, R0
            MOV NEXTSLOT, #SLOT2-SLOT0
            SJMP DISPATCH
SLOT2:      MOV A, IR1
            RLC A
            RLC A
            ANL A, #3CH
            MOV R0, A
            MOV A, IR2
            RRC A
            RRC A
            SWAP A
            ANL A, #3
            ORL A, R0
            MOV NEXTSLOT, #SLOT3-SLOT0
            SJMP DISPATCH
SLOT3:	    MOV A, IR2
            MOV NEXTSLOT, #SLOT4-SLOT0
            SJMP DISPATCH
SLOT4:	    MOV A, IR3
            RRC A
            RRC A
            MOV NEXTSLOT, #SLOT5-SLOT0
            SJMP DISPATCH
SLOT5:      MOV A, IR3
            ANL A, #3
            MOV NEXTSLOT, #SLOT6-SLOT0
            SJMP DISPATCH
SLOT6:      MOV R4, PC
            MOV R5, PC+1
            MOV R6, PC+2
            MOV R7, PC+3
            RET
;64-way jump uses a table of LJMP to functions. All functions jump to NEXT.
DISPATCH:   ;ACC = ??oooooo where oooooo is a 6-bit opcode
            ANL A, #63
            MOV R3, A
            ADD A, ACC
            ADD A, R3
            MOV DPTR, #JumpTable
            JMP @A+DPTR

JumpTable:  LJMP NEXT                   ; 00
            LJMP NEXT                   ; 01
            LJMP NEXT                   ; 02
            LJMP NEXT                   ; 03
            LJMP NEXT                   ; 04
            LJMP NEXT                   ; 05
            LJMP NEXT                   ; 06
            LJMP NEXT                   ; 07
            LJMP NEXT                   ; 08
            LJMP NEXT                   ; 09
            LJMP NEXT                   ; 0A
            LJMP NEXT                   ; 0B
            LJMP NEXT                   ; 0C
            LJMP NEXT                   ; 0D
            LJMP NEXT                   ; 0E
            LJMP NEXT                   ; 0F
            LJMP NEXT                   ; 10
            LJMP NEXT                   ; 11
            LJMP NEXT                   ; 12
            LJMP NEXT                   ; 13
            LJMP NEXT                   ; 14
            LJMP NEXT                   ; 15
            LJMP NEXT                   ; 16
            LJMP NEXT                   ; 17
            LJMP NEXT                   ; 18
            LJMP NEXT                   ; 19
            LJMP NEXT                   ; 1A
            LJMP NEXT                   ; 1B
            LJMP NEXT                   ; 1C
            LJMP NEXT                   ; 1D
            LJMP NEXT                   ; 1E
            LJMP NEXT                   ; 1F
            LJMP NEXT                   ; 20
            LJMP NEXT                   ; 21
            LJMP NEXT                   ; 22
            LJMP NEXT                   ; 23
            LJMP NEXT                   ; 24
            LJMP NEXT                   ; 25
            LJMP NEXT                   ; 26
            LJMP NEXT                   ; 27
            LJMP NEXT                   ; 28
            LJMP NEXT                   ; 29
            LJMP NEXT                   ; 2A
            LJMP NEXT                   ; 2B
            LJMP NEXT                   ; 2C
            LJMP NEXT                   ; 2D
            LJMP NEXT                   ; 2E
            LJMP NEXT                   ; 2F
            LJMP NEXT                   ; 30
            LJMP NEXT                   ; 31
            LJMP NEXT                   ; 32
            LJMP NEXT                   ; 33
            LJMP NEXT                   ; 34
            LJMP NEXT                   ; 35
            LJMP NEXT                   ; 36
            LJMP NEXT                   ; 37
            LJMP NEXT                   ; 38
            LJMP NEXT                   ; 39
            LJMP NEXT                   ; 3A
            LJMP NEXT                   ; 3B
            LJMP NEXT                   ; 3C
            LJMP NEXT                   ; 3D
            LJMP NEXT                   ; 3E
            LJMP NEXT                   ; 3F

END

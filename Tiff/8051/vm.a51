;32-bit Virtual Machine and application ROM for 8051, flavor SiLabs EFM8LB1.
;STATUS: Assembles without errors but UNTESTED

;This file was generated by Tiff using template.A51 -- don't edit this file.
;Generated Wed Apr 03 16:43:49 2019

;The VM model interfaces with Keil C51 C functions, which use R4R5R6R7 as the
;return value as well as the _long_ non-pointer first parameter.
;The first pointer parameter is R2R1R0. User functions pass N to this.

$NOMOD51
#include "SI_EFM8LB1_Defs.inc"
XRAMsize    EQU 1000H                  ;XRAM size of MCU in bytes

;The VM's USER function is free to trash the registers since it's the last
;executed slot. Otherwise, the VM uses R0-R3 as scratchpad.
;The RAM (with RAMsize 32-bit words) is implemented in XRAM.
;XRAMsize is used to place the VM's RAM at the top of XRAM. The linker will see it.

ROMsize     EQU 504*4 ;bytes in ROM (at end of this file)

;-------------------------------------------------------------------------------
;The Keil C51/A51 compiler (assembled code/data) is big endian.
;The VM (code, stack and data space) is little endian.
;IRAM data is big endian, XRAM (and all other) data is little endian.

            NAME VMstuff

            PUBLIC _VM                  ;uint32_t VM(uint32_t IR);
            PUBLIC VMpor                ;void VMpor(void);

ExtFnTable  EQU 0x00A0

;Absolute XDATA is used for the RAM of the VM.
            XSEG AT XRAMsize - (4*512)
RAM:        DS 4*512
;Size is assumed to be a power-of-2 multiple of 256-byte pages in size.
;This allows a byte-wide bit mask to wrap the RAM address.
RAMpages    EQU (512 >> 6)
ROMpages    EQU (2048 >> 6)


?ID?VM      SEGMENT DATA                ;Direct RAM
?BI?VM      SEGMENT BIT                 ;Bit space
?PR?VM      SEGMENT CODE                ;Code space

            RSEG ?ID?VM

;PC and SP are reserved symbols, put a V in front.
T:          DS 4                        ;top of stack
N:          DS 4                        ;next on stack
VPC:        DS 4                        ;program counter
DebugReg:   DS 4
IR:         DS 4                        ;instruction register
RP:         DS 2                        ;return stack pointer = 64
VSP:        DS 2                        ;return stack pointer = 32
UP:         DS 2                        ;return stack pointer = 64
Scratch:    DS 7                        ;scratchpad storage
NEXTSLOT:   DS 1                        ;state for slot jump
SLOTID:     DS 1                        ;slot ID for IMM mask lookup

            RSEG ?BI?VM
CARRY:      DBIT 1                      ;carry flag

;-------------------------------------------------------------------------------

            RSEG ?PR?VM					;code is ~2kB plus ROM size
            USING 0
;void SetDbgReg(uint32_t n);            ;write to the debug mailbox
SetDbgReg:  MOV DebugReg+0, R4
            MOV DebugReg+1, R5
            MOV DebugReg+2, R6
            MOV DebugReg+3, R7
            RET

;uint32_t GetDbgReg(void);              ;read from the debug mailbox
_GetDbgReg: MOV R4, DebugReg+0
            MOV R5, DebugReg+1
            MOV R6, DebugReg+2
            MOV R7, DebugReg+3
            RET

VMinitTable:
            DW RAM+64, RAM+32, RAM+64   ;registers for VM

;void VMpor(void);                      ;initialize the VM
VMpor:      MOV R0, #T                  ;-> first Direct RAM
            MOV R1, #16
            CLR A
VMpor0:         MOV @R0, A              ;clear first 4 longs
                INC R0
                DJNZ R1, VMpor0
            MOV DPTR, #VMinitTable
            MOV R1, #6
VMpor1:         CLR A                   ;load 3 halfwords from table
                MOVC A, @A+DPTR
                INC DPTR
                MOV @R0, A
                INC R0
                DJNZ R1, VMpor1
            MOV DPTR, #RAM              ;clear all of RAM
            MOV R2, #RAMpages
            CLR A
VMpor2:         MOVX @DPTR, A           ;clear page
                DJNZ R1, VMpor1
                DJNZ R2, VMpor1
            RET

;-------------------------------------------------------------------------------

;uint32_t VM(uint32_t IR); IR is in r4r5r6r7.
_VM:        MOV IR, R4                  ;execute an instruction group
            MOV IR+1, R5
            MOV IR+2, R6
            MOV IR+3, R7
            MOV R4, T
            MOV R5, T+1
            MOV R6, T+2
            MOV R7, T+3
            CLR A
            MOV NEXTSLOT, A
            MOV SLOTID, A
            INC VPC+3                    ;VPC++
            JNC NEXT
            INC VPC+2
            JNC NEXT
            INC VPC+1
            JNC NEXT
            INC VPC
NEXT:	    MOV DPTR, #SLOT0
            MOV A, NEXTSLOT
            JMP @A+DPTR
SLOT0:      MOV A, IR
            RRC A
            RRC A
            MOV NEXTSLOT, #SLOT1-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT1:      MOV A, IR+1
            SWAP A
            ANL A, #0FH
            MOV R0, A
            MOV A, IR
            SWAP A
            ANL A, #30H
            ORL A, R0
            MOV NEXTSLOT, #SLOT2-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT2:      MOV A, IR+1
            RLC A
            RLC A
            ANL A, #3CH
            MOV R0, A
            MOV A, IR+2
            RRC A
            RRC A
            SWAP A
            ANL A, #3
            ORL A, R0
            MOV NEXTSLOT, #SLOT3-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT3:	    MOV A, IR+2
            MOV NEXTSLOT, #SLOT4-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT4:	    MOV A, IR+3
            RRC A
            RRC A
            MOV NEXTSLOT, #SLOT5-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT5:      MOV A, IR+3
            ANL A, #3
            MOV NEXTSLOT, #SLOT6-SLOT0
            INC SLOTID
            SJMP DISPATCH
EX:
SLOT6:      MOV T, R4
            MOV T+1, R5
            MOV T+2, R6
            MOV T+3, R7
            MOV R4, VPC
            MOV R5, VPC+1
            MOV R6, VPC+2
            MOV R7, VPC+3
            RET
;64-way jump uses a table of LJMP to functions. All functions jump to NEXT.
DISPATCH:   ;ACC = ??oooooo where oooooo is a 6-bit opcode
            ANL A, #63
            MOV R3, A
            ADD A, ACC
            ADD A, R3
            MOV DPTR, #JumpTable
            JMP @A+DPTR

JumpTable:  LJMP NEXT         ;(000)  // nop
            LJMP opDUP        ;(001)  // dup
            LJMP opEXIT       ;(002)  // exit
            LJMP opADD        ;(003)  // +
            LJMP opUSER       ;(004)  // user
            LJMP opZeroLess   ;(005)  // 0<
            LJMP opPOP        ;(006)  // r>
            LJMP opTwoDiv     ;(007)  // 2/

            LJMP opSKIPNC     ;(010)  // ifc:  slot=end if no carry
            LJMP opOnePlus    ;(011)  // 1+
            LJMP opSWAP       ;(012)  // swap
            LJMP opSUB        ;(013)  // -
            LJMP NEXT
            LJMP opCstorePlus ;(015)  // c!+  ( c a -- a+1 )
            LJMP opCfetchPlus ;(016)  // c@+  ( a -- a+1 c )
            LJMP opUtwoDiv    ;(017)  // u2/

            LJMP opSKIP       ;(020)  // no:  skip remaining slots
            LJMP opTwoPlus    ;(021)  // 2+
            LJMP opSKIPNZ     ;(022)  // ifz:
            LJMP opJUMP       ;(023)  // jmp
            LJMP NEXT
            LJMP opWstorePlus ;(025)  // w!+  ( n a -- a+2 )
            LJMP opWfetchPlus ;(026)  // w@+  ( a -- a+2 n )
            LJMP opAND        ;(027)  // and

            LJMP NEXT
            LJMP opLitX       ;(031)  // litx
            LJMP opPUSH       ;(032)  // >r
            LJMP opCALL       ;(033)  // call
            LJMP NEXT
            LJMP opZeroEquals ;(035)  // 0=
            LJMP opWfetch     ;(036)  // w@  ( a -- n )
            LJMP opXOR        ;(037)  // xor

            LJMP opREPT       ;(040)  // rept  slot=0
            LJMP opFourPlus   ;(041)  // 4+
            LJMP opOVER       ;(042)  // over
            LJMP opADDC       ;(043)  // c+  with carry in
            LJMP NEXT
            LJMP opStorePlus  ;(045)  // !+  ( n a -- a+4 )
            LJMP opFetchPlus  ;(046)  // @+  ( a -- a+4 n )
            LJMP opTwoStar    ;(047)  // 2*

            LJMP opMiREPT     ;(050)  // -rept  slot=0 if T < 0
            LJMP NEXT
            LJMP opRP         ;(052)  // rp
            LJMP opDROP       ;(053)  // drop
            LJMP NEXT
            LJMP opSetRP      ;(055)  // rp!
            LJMP opFetch      ;(056)  // @
            LJMP opTwoStarC   ;(057)  // 2*c

            LJMP opSKIPGE     ;(060)  // -if:  slot=end if T >= 0
            LJMP NEXT
            LJMP opSP         ;(062)  // sp
            LJMP opFetchAS    ;(063)  // @as
            LJMP opSetSP      ;(065)  // sp!
            LJMP opCfetch     ;(066)  // c@
            LJMP opPORT       ;(067)  // port  ( n -- m ) swap T with port

            LJMP opSKIPLT     ;(070)  // +if:  slot=end if T < 0
            LJMP opLIT        ;(071)  // lit
            LJMP opUP         ;(072)  // up
            LJMP opStoreAS    ;(073)  // !as
            LJMP NEXT
            LJMP opSetUP      ;(075)  // up!
            LJMP opRfetch     ;(076)  // r@
;           LJMP opCOM        ;(077)  // com
            MOV A, R7
            CPL A
            MOV R7, A
            MOV A, R6
            CPL A
            MOV R6, A
            MOV A, R5
            CPL A
            MOV R5, A
            MOV A, R4
            CPL A
            MOV R4, A
            LJMP NEXT

;Common stack operations are the same as in the C model.
;The stack pointers are indices to longs. RAMsize is in longs.

SDUP:       MOV A, #VSP                  ;{ RAM[--VSP & (RAMsize-1)] = N;  N = T; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
            MOV R0, #N+3
            LCALL R0TORAM               ;write N to XRAM
            MOV N, R4
            MOV N+1, R5
            MOV N+2, R6
            MOV N+3, R7
            RET

;Push IRAM[B] to the return stack
RDUP:       MOV A, #RP                  ;{ RAM[--RP & (RAMsize-1)] = B; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
            MOV R0, B                ;write x to XRAM
R0TORAM:    MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            RET

XDUP:       MOV A, @R0                  ;predecrement pointer
            JNZ XDUP0
            DEC @R0
XDUP0:      DEC @R1

XPTR:       MOV A, @R1                  ;DPTR = (4*pointer & RAMpages-1) + RAM
            RLC A
            MOV R3, A
            MOV A, @R0
            RLC A
            MOV R2, A
            MOV A, R3
            RLC A
            ANL A, 0C0H
            MOV DPL, A
            MOV A, R2
            RLC A
            ANL A, #RAMpages-1
            ADD A, #HIGH(RAM)
            MOV DPH, A
            RET

;Push T to the return stack
RDUPT:      MOV A, #RP                  ;{ RAM[--RP & (RAMsize-1)] = T; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
TTORAM:     MOV A, R4
            MOVX @DPTR, A
            INC DPTR
            MOV A, R5
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
            INC DPTR
            MOV A, R7
            MOVX @DPTR, A
            RET
;Drop T:N from data stack
SDROP:      MOV R4, N                   ;{ T = N;  N = RAM[VSP++ & (RAMsize-1)]; }
            MOV R5, N+1
            MOV R6, N+2
            MOV R7, N+3
SNIP:       MOV A, #VSP                  ;{ N = RAM[VSP++ & (RAMsize-1)]; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            MOV B, #N+3              ;pop to N

;pop stack using pointer[r0r1] to IRAM[B], primitive of both SDROP and RDROP
XNIP:       LCALL XPTR                  ;get DPTR
            MOV A, R0
            PUSH ACC                    ;keep R0
            MOV R0, B
            LCALL RAMTOR0               ;IRAM[B] = RAM[r0r1]
            POP ACC
            INC @R1                     ;IRAM[r0r1]++
            JNC XNIPX
            MOV R0, A
            INC @R0
XNIPX:      RET

;Drop from return stack, B points to destination VM register
RDROP:      MOV A, #RP                  ;{ IRAM[B] = RAM[RP++ & (RAMsize-1)]; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            SJMP XNIP

;Read XRAM to IRAM[R0] using current DPTR. Endianness: XRAM is LE, IRAM is BE.
RAMTOR0:    MOVX A, @DPTR               ;XRAM to @R0
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            RET

;Shift right VM register pointed to by R0 one place
CELLDIV2:   MOV A, @R0                  ;IRAM[R0] /= 2
            RLC A
            SJMP CELLXDIV2
PCDIV2:     MOV R0, #VPC                 ;VPC >>= 1
CELLUDIV2:  CLR C                       ;IRAM[R0] >>= 1
CELLXDIV2:  MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            RET

PCTIMES2:   MOV R0, #VPC+3               ;VPC <<= 1
CELLTIMES2: CLR C                       ;IRAM[R0] <<= 1
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            RET


;IMMmask = ~(-1<<slot)) where slot is 26, 20, 14, 8, or 2
IMMmasks:   DW 003FFH, 0FFFFH
            DW 0000FH, 0FFFFH
            DW 00000H, 03FFFH
            DW 00000H, 000FFH
            DW 00000H, 00003H

;IMM is IR & IMMmask. Place unsigned IMM in @R0
GetIMM:     MOV DPTR, #IMMmasks
            MOV A, SLOTID
            RLC A
            RLC A
            ANL A, #03CH
            MOV R1, A                   ;A is offset into IMMmasks table
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            RET

;-------------------------------------------------------------------------------
;Opcodes

opDUP:      LCALL SDUP
            LJMP NEXT

opEXIT:     MOV B, #VPC
            LCALL RDROP
            LCALL PCDIV2
            LCALL PCDIV2
            LJMP NEXT

opADDC:     MOV C, CARRY
            SJMP opADDX
opADD:      CLR C
opADDX:     MOV A, R7
            ADDC A, N+3
            MOV R7, A
            MOV A, R6
            ADDC A, N+2
            MOV R6, A
            MOV A, R5
            ADDC A, N+1
            MOV R5, A
            MOV A, R4
            ADDC A, N+0
            MOV R4, A
            MOV CARRY, C
            LCALL SNIP
            LJMP NEXT


opUSER:     MOV R0, #IR
            LCALL GetIMM                ;IR = immediate data
            LCALL CallImmFn
            LJMP EX

CallImmFn:  MOV DPTR, #ExtFnTable
            CLR A
            MOVC A, @A+DPTR             ;get size of table
            INC DPTR
            CLR C
            SUBB A, IR+3                ;lower 8 bits are function number
            JC CallImmFnX               ;Index must be in range
                MOV R0, N+3
                MOV R1, N+2
                MOV R2, N+1             ;load pointer from N
                MOV B, #3
                MOV A, IR+3
                MUL AB
                PUSH ACC
                MOV A, B
                ADD A, DPH
                MOV DPH, A
                POP ACC
                JMP @A+DPTR
CallImmFnX: RET

opZeroEquals:
            CLR A
            MOV A, R4
            ORL A, R5
            ORL A, R6
            ORL A, R7
            JZ opMakeFlag
            CLR A
            CPL A
            SJMP opMakeFlag
opZeroLess: MOV A, R4
            RLC A
            CLR A
            RLC A                       ;1 if T<0 else 0
            DEC A
opMakeFlag: CPL A                       ;0 -> TRUE, 255 -> FALSE
            MOV R7, A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            LJMP NEXT

opPOP:      LCALL SDUP
            MOV B, #Scratch
            LCALL RDROP
ScratchToTOS:
            MOV R4, Scratch
            MOV R5, Scratch+1
            MOV R6, Scratch+2
            MOV R7, Scratch+3
            LJMP NEXT

opUtwoDiv:  CLR C
            SJMP opTwoDiv1
opTwoDiv:   MOV A, R4
            RLC A                       ;signed right shift
opTwoDiv1:  MOV A, R4
            RRC A
            MOV R4, A
            MOV A, R5
            RRC A
            MOV R5, A
            MOV A, R6
            RRC A
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
qnext:      LJMP NEXT

opSKIPNC:   MOV C, CARRY
            JC qnext
opSKIP:     LJMP EX
opSKIPNZ:   MOV A, R4
            ORL A, R5
            ORL A, R6
            ORL A, R7
            JNZ opSKIP
            LJMP NEXT
opSKIPGE:   MOV A, R4
            RLC A
            JNC opSKIP
            LJMP NEXT
opSKIPLT:   MOV A, R4
            RLC A
            JC opSKIP
            LJMP NEXT

opFourPlus: MOV A, #4
            SJMP opXPlus
opTwoPlus:  MOV A, #2
            SJMP opXPlus
opOnePlus:  MOV A, #1
opXPlus:    ADD A, R7
            MOV R7, A
            MOV A, R6
            ADDC A, R6
            MOV R6, A
            CLR A
            ADDC A, R5
            MOV R5, A
            CLR A
            ADDC A, R4
            MOV R4, A
            LJMP NEXT

opSWAP:     MOV A, R4
            XCH A, N
            MOV R4, A
            MOV A, R5
            XCH A, N+1
            MOV R5, A
            MOV A, R6
            XCH A, N+2
            MOV R6, A
            MOV A, R7
            XCH A, N+3
            MOV R7, A
            LJMP NEXT

opSUB:      CLR C
            MOV A, N+3
            SUBB A, T+3
            MOV T+3, A
            MOV A, N+2
            SUBB A, T+2
            MOV T+2, A
            MOV A, N+1
            SUBB A, T+1
            MOV T+1, A
            MOV A, N
            SUBB A, T
            MOV T, A
            MOV CARRY, C
            LCALL SNIP
            LJMP NEXT

opJUMP:     MOV R0, #VPC
            LCALL GetIMM
            LJMP EX

FetchC:     ;r4r5r6r7 = VMmem[r4r5r6r7] 16-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROMC
            ADD A, #-RAMpages
            JNC FetchRAMC
            SJMP ClearT
FetchROMC:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            MOV R7, A
            CLR A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            RET
FetchRAMC:  MOV DPL, R7         ;RAM is page-aligned
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            MOV R7, A
            CLR A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            RET

FetchW:     ;r4r5r6r7 = VMmem[r4r5r6r7] 16-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROMW
            ADD A, #-RAMpages
            JNC FetchRAMW
            SJMP ClearT
FetchROMW:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R7, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOV R5, A
            MOV R4, A
            RET
FetchRAMW:  MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            INC DPTR
            MOV R7, A
            MOVX A, @DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOV R5, A
            MOV R4, A
            RET

FetchL:     ;r4r5r6r7 = VMmem[r4r5r6r7] 32-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROML
            ADD A, #-RAMpages
            JNC FetchRAML
ClearT:     CLR A
            MOV R4, A
            MOV R5, A
            MOV R6, A
            MOV R7, A
            RET
FetchROML:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R7, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R5, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R4, A
            RET
FetchRAML:  MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            INC DPTR
            MOV R7, A
            MOVX A, @DPTR
            INC DPTR
            MOV R6, A
            MOVX A, @DPTR
            INC DPTR
            MOV R5, A
            MOVX A, @DPTR
            INC DPTR
            MOV R4, A
            RET
SetROMaddr: MOV A, R7
            ADD A, #-LOW(ROMsize)
            MOV A, R6
            ADD A, #-HIGH(ROMsize)
            JC SetROMbad
            MOV DPTR, #ROM      ;ROM is anywhere in code space
            MOV A, #HIGH(ROM)   ;Add T to get base address in DPTR
            ADD A, R7
            MOV DPL, A
            MOV A, #LOW(ROM)
            ADD A, R6
            MOV DPH, A
            RET
SetROMbad:  MOV DPTR, #ROM      ;bad address reads from beginning of ROM
            RET

opCstorePlus:                   ;VMmem[r4r5r6r7] = r7
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreCnone      ;can't store to ROM
            ADD A, #-RAMpages
            JNC StoreC
            SJMP StoreCnone
StoreC:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
StoreCnone: LJMP opOnePlus      ;nothing to store

opWstorePlus:                   ;VMmem[r4r5r6r7] = r7r6
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreWnone
            ADD A, #-RAMpages
            JNC StoreW
            SJMP StoreWnone
StoreW:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
StoreWnone: LJMP opTwoPlus

opStorePlus:                    ;VMmem[r4r5r6r7] = r7r6r5r4
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreLnone
            ADD A, #-RAMpages
            JNC StoreL
            SJMP StoreLnone
StoreL:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
            INC DPTR
            MOV A, R5
            MOVX @DPTR, A
            INC DPTR
            MOV A, R4
            MOVX @DPTR, A
StoreLnone: LJMP opFourPlus

opCfetch:   LCALL FetchC
            LJMP NEXT
opCfetchPlus:
            LCALL SDUP
            LCALL FetchC
            MOV A, #1
            LCALL BumpN
            LJMP NEXT

opWfetch:   LCALL FetchW
            LJMP NEXT
opWfetchPlus:
            LCALL SDUP
            LCALL FetchW
            MOV A, #2
            LCALL BumpN
            LJMP NEXT

opFetch:    LCALL FetchL
            LJMP NEXT
opFetchPlus:
            LCALL SDUP
            LCALL FetchL
            MOV A, #4
            LCALL BumpN
            LJMP NEXT

opAND:      MOV A, R7
            ANL A, N+3
            MOV R7, A
            MOV A, R6
            ANL A, N+2
            MOV R6, A
            MOV A, R5
            ANL A, N+1
            MOV R5, A
            MOV A, R4
            ANL A, N
            MOV R4, A
            LCALL SNIP
            LJMP NEXT

opLitX:     ;T = (T<<24) | (IMM & 0xFFFFFF);
            MOV R0, #IR
            LCALL GetIMM
            MOV A, R7
            MOV R4, A
            MOV A, IR+1
            MOV R5, A
            MOV A, IR+2
            MOV R6, A
            MOV A, IR+3
            LJMP EX

opPUSH:     LCALL RDUPT
            LCALL SDROP         ;>r
            LJMP NEXT

opCALL:     LCALL PCTIMES2
            LCALL PCTIMES2
            MOV B, #VPC
            LCALL RDUP
            MOV R0, #VPC
            LCALL GetIMM
            LJMP EX

opXOR:      MOV A, R7
            XRL A, N+3
            MOV R7, A
            MOV A, R6
            XRL A, N+2
            MOV R6, A
            MOV A, R5
            XRL A, N+1
            MOV R5, A
            MOV A, R4
            XRL A, N
            MOV R4, A
            LCALL SNIP
            LJMP NEXT

opREPT:     CLR A
            MOV NEXTSLOT, A
            MOV SLOTID, A
            LJMP NEXT

opOVER:     MOV Scratch+0, N+0
            MOV Scratch+1, N+1
            MOV Scratch+2, N+2
            MOV Scratch+3, N+3
            LCALL SDUP
            MOV R4, Scratch+0
            MOV R5, Scratch+1
            MOV R6, Scratch+2
            MOV R7, Scratch+3
            LJMP NEXT

opTwoStarC: MOV C, CARRY
            SJMP opTwoStar1
opTwoStar:  CLR C
opTwoStar1: MOV A, R7
            RLC A
            MOV R7, A
            MOV A, R6
            RLC A
            MOV R6, A
            MOV A, R5
            RLC A
            MOV R5, A
            MOV A, R4
            RLC A
            MOV R4, A
            MOV CARRY, C
            LJMP NEXT


opMiREPT:   PUSH N+2
            MOV A, #1
            LCALL BumpN
            POP ACC
            RLC A
            JC opREPT
            LJMP NEXT

BumpN:      MOV R0, #N+3
BumpReg:    ADD A, @R0          ;Add A to [R0]
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            RET

opDROP:     LCALL SDROP
            LJMP NEXT

opUP:       MOV R0, #UP
            SJMP opXP
opRP:       MOV R0, #RP
            SJMP opXP
opSP:       MOV R0, #VSP
opXP:       MOV A, @R0          ;{T += (M + ROMsize)*4;}
            INC R0
            ADD A, #ROMpages    ;ROMsize/256
            MOV R2, A
            MOV A, @R0
            CLR C
            RLC A
            MOV R3, A           ;r2r3 = XP + ROMsize
            MOV A, R2
            RLC A
            MOV R2, A
            CLR C
            MOV A, R3
            RLC A
            MOV R3, A           ;r2r3 = (XP + ROMsize) << 2
            MOV A, R2
            RLC A
            MOV R2, A
            MOV A, R3
            ADD A, R7
            MOV R7, A
            MOV A, R2
            ADDC A, R6
            MOV R6, A
            CLR A
            ADDC A, R5
            MOV R5, A
            CLR A
            ADDC A, R4
            MOV R4, A
            LJMP NEXT


;not implemented
opStoreAS:
opFetchAS:  LJMP NEXT

opPORT:     MOV A, R4
            XCH A, DebugReg+0
            MOV R4, A
            MOV A, R5
            XCH A, DebugReg+0
            MOV R5, A
            MOV A, R6
            XCH A, DebugReg+0
            MOV R6, A
            MOV A, R7
            XCH A, DebugReg+0
            MOV R7, A
            LJMP NEXT

opLIT:      MOV R0, #IR
            LCALL GetIMM
            MOV R4, IR
            MOV R5, IR+1
            MOV R6, IR+2
            MOV R7, IR+3
            LJMP EX

TTOXP:      CLR C               ; r6r7 = (T>>2) & (RAMsize-1), assume RAMsize < 16K
            MOV A, R6
            RRC A
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
            CLR C
            MOV A, R6
            RRC A
            ANL A, #RAMpages-1
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
            RET

opSetRP:    MOV B, #RP
            SJMP SetXP
opSetUP:    MOV B, #UP       ;UP = (T>>2) & (RAMsize-1);
SetXP:      LCALL TTOXP
            MOV R0, B
            MOV A, R6
            MOV @R0, A
            INC R0
            MOV A, R7
            MOV @R0, A
            LCALL SDROP
            LJMP NEXT

opSetSP:    LCALL TTOXP
            MOV R0, #VSP
            MOV A, R6
            MOV @R0, A
            INC R0
            MOV A, R7
            MOV @R0, A
            LJMP NEXT

opRfetch:   LCALL SDUP
            MOV B, #Scratch
            LCALL RDROP
            LJMP ScratchToTOS

ROM:
DW 04C00H,001EFH, 096B0H,09000H, 036B0H,09000H, 056B0H,09000H, 005ABH,08318H, 096B0H,09000H
DW 005ADH,08318H, 036B0H,09000H, 0FC90H,09000H, 0FC9FH,0C240H, 09E70H,09000H, 068A1H,08A08H
DW 029A2H,08608H, 02A20H,09000H, 02AB0H,09000H, 02862H,09A28H, 069A0H,09000H, 01862H,08628H
DW 068A0H,09000H, 0186FH,08A68H, 02BE2H,09A08H, 0AEB0H,09000H, 08A20H,09000H, 068A1H,08A68H
DW 068A1H,08A1AH, 069A8H,0A218H, 01930H,00017H, 06C00H,0000FH, 06C00H,00017H, 06C00H,00011H
DW 04C00H,00017H, 06C00H,0001BH, 04C00H,0001BH, 06C00H,00017H, 0AEB0H,09000H, 06C00H,00017H
DW 04C00H,00019H, 0AEBAH,0C240H, 00520H,09000H, 00424H,00000H, 00780H,05F08H, 005FFH,0C240H
DW 07DD0H,09000H, 07DD7H,04240H, 075D0H,09000H, 0FC91H,04240H, 0449EH,04003H, 0FD70H,09000H
DW 06A71H,0AF08H, 098ABH,08A08H, 0965AH,0C240H, 0C3F2H,05000H, 00900H,00000H, 069A2H,0860CH
DW 02868H,0C240H, 0FCAFH,0D7FEH, 06824H,00000H, 0FDAFH,0C918H, 089DCH,02B26H, 0AC24H,00000H
DW 0C130H,00039H, 00900H,00000H, 0E400H,00004H, 0CAE0H,09000H, 0E400H,00008H, 0CAE0H,09000H
DW 0E400H,0000CH, 0EAEEH,04008H, 0C8B1H,0C708H, 00679H,0F2B8H, 02AB0H,09000H, 0E400H,0000AH
DW 0E400H,02218H, 096B0H,09000H, 0E400H,00010H, 0E400H,02218H, 096B0H,09000H, 0B900H,00000H
DW 0E4FFH,0FFFFH, 05C24H,00000H, 0FC94H,00000H, 0E2BAH,0EB08H, 024A6H,08A40H, 09869H,05AA0H
DW 01ABAH,0EB08H, 0FC94H,00000H, 0E2BAH,0EB08H, 024A6H,08A40H, 03863H,05AA0H, 01ABAH,0EB08H
DW 02BF2H,05000H, 0E2BAH,0EB08H, 024A6H,08A40H, 0F8A3H,06818H, 0AEBAH,0C240H, 0E400H,0003FH
DW 05FF2H,078AEH, 024A4H,00000H, 09E82H,0AB08H, 00900H,00000H, 0E400H,0003FH, 05FF2H,078AEH
DW 024A4H,00000H, 03E82H,0AB08H, 00900H,00000H, 0E400H,00000H, 0E400H,0001FH, 0FD00H,00000H
DW 06A76H,0AF40H, 02221H,08368H, 02094H,00000H, 01862H,05000H, 0C130H,0006CH, 0ADA6H,0AB18H
DW 018A0H,09000H, 0AEBAH,0F900H, 0FC10H,09000H, 08A22H,0EB40H, 02130H,00073H, 0E400H,0001FH
DW 0FCF9H,0D000H, 069A6H,0AF18H, 0BC84H,0C07EH, 007E2H,0EB40H, 023E2H,0D000H, 04C00H,00080H
DW 0F8BEH,04000H, 09EB4H,00000H, 01862H,05000H, 0C130H,00079H, 0AEB2H,0AF08H, 00450H,05A40H
DW 04930H,00087H, 0FC96H,09B39H, 01900H,00000H, 06811H,05000H, 04930H,0008AH, 0F834H,00000H
DW 019B0H,00075H, 01924H,0C08DH, 02BF2H,04A40H, 00900H,00000H, 08852H,09383H, 06C00H,0008EH
DW 0AC24H,00000H, 06C00H,0008EH, 02AB0H,09000H, 08A27H,0C540H, 048B1H,04240H, 02AB1H,04240H
DW 02930H,00093H, 08A27H,0C540H, 048B1H,04240H, 0AC50H,09000H, 02930H,00097H, 08A26H,0C097H
DW 048A4H,00000H, 0AC24H,00000H, 08A22H,09B97H, 048A4H,00000H, 0AC24H,00000H, 08A26H,0C093H
DW 048A4H,00000H, 0AC24H,00000H, 08A22H,09B93H, 048A4H,00000H, 0AC24H,00000H, 068AFH,08328H
DW 018B0H,09000H, 088B6H,08B18H, 04C00H,00093H, 02930H,00093H, 02930H,00097H, 06C00H,00069H
DW 0AC24H,00000H, 08A27H,0C568H, 06C00H,00033H, 029B0H,00033H, 06C00H,00069H, 01924H,0C0B5H
DW 06C00H,00039H, 00900H,00000H, 069B0H,000AFH, 01930H,00083H, 06C00H,000B6H, 02AB0H,09000H
DW 089AEH,04004H, 0C9AEH,06214H, 0B9AEH,04000H, 0AB90H,02214H, 096B6H,0C038H, 01B90H,02214H
DW 096B1H,0AB19H, 07C24H,00000H, 0052AH,0C240H, 0E400H,02214H, 0BAD1H,09000H, 0E400H,02214H
DW 096B1H,08A68H, 0D6B2H,0AB18H, 018A0H,09000H, 086E0H,06E6AH, 0F790H,00010H, 0EAEDH,06BB6H
DW 0E400H,00000H, 0EB90H,00004H, 0EA5AH,0D000H, 0E400H,00328H, 0E400H,00000H, 0EA5AH,0C240H
DW 0E400H,00000H, 0A81EH,04004H, 0CB90H,00010H, 0EA5AH,0F904H, 0EAE0H,06E6AH, 0E400H,00000H
DW 0E8B0H,0C240H, 0E400H,00324H, 0E400H,00000H, 0EA5AH,0D3D2H, 0E400H,00324H, 02A5AH,0C240H
DW 0E400H,00328H, 02A5AH,0C240H, 007D0H,07904H, 0EA5AH,0C168H, 029A0H,0C318H, 0883EH,04004H
DW 0EA19H,065ACH, 01930H,000DCH, 0E400H,00004H, 0EAE8H,0B904H, 0EA5AH,0DA40H, 06C00H,000E0H
DW 01B90H,00004H, 0EA5AH,0C240H, 00618H,06640H, 0E400H,00004H, 02CABH,0B904H, 02CA1H,0A294H
DW 0AE29H,06B88H, 0E400H,00010H, 0E9B0H,000D7H, 096B4H,0C0DEH, 00440H,00004H, 00900H,00000H
DW 0E400H,0000AH, 06C00H,000ADH, 06C00H,000F4H, 00D00H,00000H, 005B0H,000F4H, 06C00H,00097H
DW 04930H,000FAH, 0AC24H,00000H, 06C00H,000D2H, 00440H,00003H, 04930H,000FEH, 01000H,00002H
DW 0AC24H,00000H, 04C00H,00137H, 03930H,00103H, 0FF0AH,00D02H, 0325BH,01B04H, 0FFFFH,0FF4AH
DW 0E400H,00414H, 04C00H,00104H, 0E400H,00418H, 04C00H,00104H, 00000H,003F8H, 00000H,00420H
DW 00000H,00428H, 0E400H,00430H, 0E400H,02234H, 096B0H,09000H, 09E7EH,06234H, 0B83BH,09A08H
DW 0E400H,00000H, 04C00H,00112H, 0E400H,00001H, 04C00H,00112H, 0E400H,00002H, 04C00H,00112H
DW 089AFH,0C9FCH, 02892H,086DAH, 0E400H,00006H, 06C00H,0005FH, 069B0H,0011AH, 0E400H,0003FH
DW 05C60H,0C240H, 06C00H,0011AH, 00790H,000C0H, 05F90H,00080H, 07DD4H,00000H, 04930H,00127H
DW 0AD30H,00121H, 00790H,00080H, 05D24H,0C136H, 00790H,00020H, 05D24H,0C134H, 00790H,00010H
DW 05D24H,0C131H, 0E400H,00007H, 05DB0H,0011CH, 06C00H,0011CH, 04C00H,0011CH, 0E400H,0000FH
DW 05DB0H,0011CH, 04C00H,0011CH, 0E400H,0001FH, 05D30H,0011CH, 00900H,00000H, 007F2H,07F14H
DW 0FD24H,0C13CH, 06C00H,00121H, 06C00H,00114H, 04C00H,00137H, 0AEB0H,09000H, 0E400H,00020H
DW 04C00H,00114H, 0FC94H,00000H, 0E2B0H,09000H, 06C00H,0013DH, 02530H,00140H, 00900H,00000H
DW 0E400H,00009H, 089B0H,00097H, 0E400H,00007H, 05C3EH,04030H, 00C24H,00000H, 0E400H,02350H
DW 0E400H,02284H, 096B0H,09000H, 0E400H,02284H, 0BBF2H,07F04H, 0E400H,02284H, 096B3H,06B08H
DW 0E400H,00000H, 0E400H,02218H, 0B9B0H,00075H, 06B90H,02218H, 0B9B0H,00075H, 029B0H,00144H
DW 06C00H,0014CH, 01824H,00000H, 06C00H,00150H, 08A26H,0C037H, 07524H,0C158H, 00900H,00000H
DW 01524H,0C15FH, 0E400H,0002DH, 06C00H,0014CH, 00900H,00000H, 0AEBEH,06284H, 0BB90H,02350H
DW 088B0H,09000H, 088B6H,0C13FH, 04C00H,00103H, 06816H,09B3CH, 06C00H,00149H, 06C00H,00158H
DW 019B0H,0015CH, 06C00H,00160H, 01930H,00163H, 0E400H,00000H, 02930H,00165H, 069B0H,00028H
DW 01930H,00165H, 0E400H,00000H, 06C00H,00165H, 04C00H,0013DH, 0E400H,00000H, 04C00H,0016FH
DW 0E400H,02218H, 0BB90H,0000AH, 07D24H,0C178H, 04C00H,00172H, 06C00H,00028H, 04C00H,0016FH
DW 0B930H,00174H, 06C00H,00149H, 0FC94H,00000H, 069B0H,00150H, 01894H,00000H, 0C130H,0017DH
DW 0ADB0H,00158H, 04C00H,00160H, 0E400H,02218H, 0B9A6H,0C04AH, 0E400H,00000H, 029B0H,0017BH
DW 01B90H,02218H, 096B6H,0C103H, 04C00H,0013DH, 01000H,00005H, 00900H,00000H, 069B0H,00189H
DW 0AF90H,02284H, 005A9H,06B18H, 039A3H,09AD8H, 06C00H,00189H, 0AC66H,0C189H, 0AC61H,08340H
DW 06C00H,00189H, 0AC24H,00000H, 0E400H,02284H, 006E6H,08A68H, 069B0H,00189H, 0AFE9H,06B18H
DW 039A3H,09AD8H, 06C00H,00189H, 0AC66H,0C189H, 0AC61H,08340H, 06C00H,00189H, 0AC6EH,06284H
DW 096B0H,09000H, 0E400H,00005H, 06C00H,00189H, 0AF90H,001FFH, 04C00H,00189H, 06C00H,0019FH
DW 0E400H,00001H, 05DD4H,00000H, 04930H,001A3H, 00900H,00000H, 0E400H,0009FH, 06C00H,00189H
DW 005F6H,0C189H, 005F6H,0C189H, 005F4H,0C189H, 0E400H,00106H, 06C00H,00189H, 0AF90H,00020H
DW 0E400H,00100H, 06C00H,00194H, 0E400H,00104H, 06C00H,00189H, 0AD30H,001A3H, 0E400H,00106H
DW 06C00H,00189H, 0ACAEH,04002H, 0E400H,00000H, 06C00H,00194H, 0FC9FH,0DA38H, 0F9D4H,00000H
DW 04930H,001C3H, 0E400H,00100H, 00DB0H,00189H, 0AF90H,00104H, 06C00H,00189H, 0ADB0H,001A3H
DW 01AB0H,09000H, 06C00H,00189H, 0AC64H,0C1BAH, 00900H,00000H, 0052AH,0EBAEH, 08BFEH,040FFH
DW 05C98H,09A40H, 06C00H,0009BH, 068A8H,0BE40H, 06C00H,001B5H, 02BE0H,0C618H, 028B4H,0C1C6H
DW 00900H,00000H, 02B90H,02284H, 096BEH,06284H, 02B90H,00004H, 04C00H,001C6H, 0E400H,000FFH
DW 06C00H,00189H, 028D0H,09000H, 0E400H,0000BH, 0E400H,00000H, 06C00H,00194H, 005B0H,00189H
DW 0AF90H,02284H, 06C00H,001D3H, 06C00H,001D3H, 06C00H,001D3H, 06C00H,001D3H, 0AF90H,001FFH
DW 06C00H,00189H, 0AF90H,02284H, 0B824H,00000H, 01B90H,02218H, 096BEH,06200H, 0F790H,02100H
DW 00790H,0000CH, 0EA5AH,0F540H, 0E400H,021F0H, 00790H,00008H, 0EA5AH,0F904H, 02ED6H,0C0CCH
DW 06C00H,0010FH, 0E400H,02218H, 0B9A4H,0C047H, 06C00H,001E3H, 04C00H,001F4H, 06C65H,0480BH
DW 05720H,06F6CH, 0646CH,0726FH, 0E400H,007C4H, 039B0H,00103H, 01000H,00006H, 00900H,00000H


END

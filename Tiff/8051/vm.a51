;32-bit Virtual Machine and application ROM for 8051, flavor SiLabs EFM8LB1.
;STATUS: Assembles without errors but UNTESTED

;This file was generated by Tiff using template.A51 -- don't edit this file.
;Generated Wed Apr 17 17:28:23 2019

;The VM model interfaces with Keil C51 C functions, which use R4R5R6R7 as the
;return value as well as the _long_ non-pointer first parameter.
;The first pointer parameter is R2R1R0. User functions pass N to this.

$NOMOD51
#include "SI_EFM8LB1_Defs.inc"
XRAMsize    EQU 1000H                  ;XRAM size of MCU in bytes

;The VM's USER function is free to trash the registers since it's the last
;executed slot. Otherwise, the VM uses R0-R3 as scratchpad.
;The RAM (with RAMsize 32-bit words) is implemented in XRAM.
;XRAMsize is used to place the VM's RAM at the top of XRAM. The linker will see it.

ROMsize     EQU 536*4 ;bytes in ROM (at end of this file)

;-------------------------------------------------------------------------------
;The Keil C51/A51 compiler (assembled code/data) is big endian.
;The VM (code, stack and data space) is little endian.
;IRAM data is big endian, XRAM (and all other) data is little endian.

            NAME VMstuff

            PUBLIC _VMstep              ;uint32_t VMstep(uint32_t IR);
            PUBLIC VMpor                ;void VMpor(void);
            PUBLIC SetDbgReg            ;void SetDbgReg(uint32_t n);
            PUBLIC _GetDbgReg           ;uint32_t GetDbgReg(void);

ExtFnTable  EQU 0x00A0

;Absolute XDATA is used for the RAM of the VM.
            XSEG AT XRAMsize - (4*512)
RAM:        DS 4*512
;Size is assumed to be a power-of-2 multiple of 256-byte pages in size.
;This allows a byte-wide bit mask to wrap the RAM address.
RAMpages    EQU (512 >> 6)
ROMpages    EQU (8192 >> 6)


?ID?VM      SEGMENT DATA                ;Direct RAM
?BI?VM      SEGMENT BIT                 ;Bit space
?PR?VM      SEGMENT CODE                ;Code space

            RSEG ?ID?VM

;PC and SP are reserved symbols, put a V in front.
T:          DS 4                        ;top of stack
N:          DS 4                        ;next on stack
VPC:        DS 4                        ;program counter
DebugReg:   DS 4
IR:         DS 4                        ;instruction register
RP:         DS 2                        ;return stack pointer = 64
VSP:        DS 2                        ;return stack pointer = 32
UP:         DS 2                        ;return stack pointer = 64
Scratch:    DS 7                        ;scratchpad storage
NEXTSLOT:   DS 1                        ;state for slot jump
SLOTID:     DS 1                        ;slot ID for IMM mask lookup

            RSEG ?BI?VM
CARRY:      DBIT 1                      ;carry flag

;-------------------------------------------------------------------------------

            RSEG ?PR?VM					;code is ~2kB plus ROM size
            USING 0
;void SetDbgReg(uint32_t n);            ;write to the debug mailbox
SetDbgReg:  MOV DebugReg+0, R4
            MOV DebugReg+1, R5
            MOV DebugReg+2, R6
            MOV DebugReg+3, R7
            RET

;uint32_t GetDbgReg(void);              ;read from the debug mailbox
_GetDbgReg: MOV R4, DebugReg+0
            MOV R5, DebugReg+1
            MOV R6, DebugReg+2
            MOV R7, DebugReg+3
            RET

VMinitTable:
            DW RAM+64, RAM+32, RAM+64   ;registers for VM

;void VMpor(void);                      ;initialize the VM
VMpor:      MOV R0, #T                  ;-> first Direct RAM
            MOV R1, #16
            CLR A
VMpor0:         MOV @R0, A              ;clear first 4 longs
                INC R0
                DJNZ R1, VMpor0
            MOV DPTR, #VMinitTable
            MOV R1, #6
VMpor1:         CLR A                   ;load 3 halfwords from table
                MOVC A, @A+DPTR
                INC DPTR
                MOV @R0, A
                INC R0
                DJNZ R1, VMpor1
            MOV DPTR, #RAM              ;clear all of RAM
            MOV R2, #RAMpages
            CLR A
VMpor2:         MOVX @DPTR, A           ;clear page
                DJNZ R1, VMpor1
                DJNZ R2, VMpor1
            RET

;-------------------------------------------------------------------------------

;uint32_t VM(uint32_t IR); IR is in r4r5r6r7.
_VM:        MOV IR, R4                  ;execute an instruction group
            MOV IR+1, R5
            MOV IR+2, R6
            MOV IR+3, R7
            MOV R4, T
            MOV R5, T+1
            MOV R6, T+2
            MOV R7, T+3
            CLR A
            MOV NEXTSLOT, A
            MOV SLOTID, A
            INC VPC+3                    ;VPC++
            JNC NEXT
            INC VPC+2
            JNC NEXT
            INC VPC+1
            JNC NEXT
            INC VPC
NEXT:	    MOV DPTR, #SLOT0
            MOV A, NEXTSLOT
            JMP @A+DPTR
SLOT0:      MOV A, IR
            RRC A
            RRC A
            MOV NEXTSLOT, #SLOT1-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT1:      MOV A, IR+1
            SWAP A
            ANL A, #0FH
            MOV R0, A
            MOV A, IR
            SWAP A
            ANL A, #30H
            ORL A, R0
            MOV NEXTSLOT, #SLOT2-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT2:      MOV A, IR+1
            RLC A
            RLC A
            ANL A, #3CH
            MOV R0, A
            MOV A, IR+2
            RRC A
            RRC A
            SWAP A
            ANL A, #3
            ORL A, R0
            MOV NEXTSLOT, #SLOT3-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT3:	    MOV A, IR+2
            MOV NEXTSLOT, #SLOT4-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT4:	    MOV A, IR+3
            RRC A
            RRC A
            MOV NEXTSLOT, #SLOT5-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT5:      MOV A, IR+3
            ANL A, #3
            MOV NEXTSLOT, #SLOT6-SLOT0
            INC SLOTID
            SJMP DISPATCH
EX:
SLOT6:      MOV T, R4
            MOV T+1, R5
            MOV T+2, R6
            MOV T+3, R7
            MOV R4, VPC
            MOV R5, VPC+1
            MOV R6, VPC+2
            MOV R7, VPC+3
            RET
;64-way jump uses a table of LJMP to functions. All functions jump to NEXT.
DISPATCH:   ;ACC = ??oooooo where oooooo is a 6-bit opcode
            ANL A, #63
            MOV R3, A
            ADD A, ACC
            ADD A, R3
            MOV DPTR, #JumpTable
            JMP @A+DPTR

JumpTable:  LJMP NEXT         ;(000)  // nop
            LJMP opDUP        ;(001)  // dup
            LJMP opEXIT       ;(002)  // exit
            LJMP opADD        ;(003)  // +
            LJMP opUSER       ;(004)  // user
            LJMP opZeroLess   ;(005)  // 0<
            LJMP opPOP        ;(006)  // r>
            LJMP opTwoDiv     ;(007)  // 2/

            LJMP opSKIPNC     ;(010)  // ifc:  slot=end if no carry
            LJMP opOnePlus    ;(011)  // 1+
            LJMP opSWAP       ;(012)  // swap
            LJMP opSUB        ;(013)  // -
            LJMP NEXT
            LJMP opCstorePlus ;(015)  // c!+  ( c a -- a+1 )
            LJMP opCfetchPlus ;(016)  // c@+  ( a -- a+1 c )
            LJMP opUtwoDiv    ;(017)  // u2/

            LJMP opSKIP       ;(020)  // no:  skip remaining slots
            LJMP opTwoPlus    ;(021)  // 2+
            LJMP opSKIPNZ     ;(022)  // ifz:
            LJMP opJUMP       ;(023)  // jmp
            LJMP NEXT
            LJMP opWstorePlus ;(025)  // w!+  ( n a -- a+2 )
            LJMP opWfetchPlus ;(026)  // w@+  ( a -- a+2 n )
            LJMP opAND        ;(027)  // and

            LJMP NEXT
            LJMP opLitX       ;(031)  // litx
            LJMP opPUSH       ;(032)  // >r
            LJMP opCALL       ;(033)  // call
            LJMP NEXT
            LJMP opZeroEquals ;(035)  // 0=
            LJMP opWfetch     ;(036)  // w@  ( a -- n )
            LJMP opXOR        ;(037)  // xor

            LJMP opREPT       ;(040)  // rept  slot=0
            LJMP opFourPlus   ;(041)  // 4+
            LJMP opOVER       ;(042)  // over
            LJMP opADDC       ;(043)  // c+  with carry in
            LJMP NEXT
            LJMP opStorePlus  ;(045)  // !+  ( n a -- a+4 )
            LJMP opFetchPlus  ;(046)  // @+  ( a -- a+4 n )
            LJMP opTwoStar    ;(047)  // 2*

            LJMP opMiREPT     ;(050)  // -rept  slot=0 if T < 0
            LJMP NEXT
            LJMP opRP         ;(052)  // rp
            LJMP opDROP       ;(053)  // drop
            LJMP NEXT
            LJMP opSetRP      ;(055)  // rp!
            LJMP opFetch      ;(056)  // @
            LJMP opTwoStarC   ;(057)  // 2*c

            LJMP opSKIPGE     ;(060)  // -if:  slot=end if T >= 0
            LJMP NEXT
            LJMP opSP         ;(062)  // sp
            LJMP opFetchAS    ;(063)  // @as
            LJMP opSetSP      ;(065)  // sp!
            LJMP opCfetch     ;(066)  // c@
            LJMP opPORT       ;(067)  // port  ( n -- m ) swap T with port

            LJMP opSKIPLT     ;(070)  // +if:  slot=end if T < 0
            LJMP opLIT        ;(071)  // lit
            LJMP opUP         ;(072)  // up
            LJMP opStoreAS    ;(073)  // !as
            LJMP NEXT
            LJMP opSetUP      ;(075)  // up!
            LJMP opRfetch     ;(076)  // r@
;           LJMP opCOM        ;(077)  // com
            MOV A, R7
            CPL A
            MOV R7, A
            MOV A, R6
            CPL A
            MOV R6, A
            MOV A, R5
            CPL A
            MOV R5, A
            MOV A, R4
            CPL A
            MOV R4, A
            LJMP NEXT

;Common stack operations are the same as in the C model.
;The stack pointers are indices to longs. RAMsize is in longs.

SDUP:       MOV A, #VSP                  ;{ RAM[--VSP & (RAMsize-1)] = N;  N = T; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
            MOV R0, #N+3
            LCALL R0TORAM               ;write N to XRAM
            MOV N, R4
            MOV N+1, R5
            MOV N+2, R6
            MOV N+3, R7
            RET

;Push IRAM[B] to the return stack
RDUP:       MOV A, #RP                  ;{ RAM[--RP & (RAMsize-1)] = B; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
            MOV R0, B                ;write x to XRAM
R0TORAM:    MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            RET

XDUP:       MOV A, @R0                  ;predecrement pointer
            JNZ XDUP0
            DEC @R0
XDUP0:      DEC @R1

XPTR:       MOV A, @R1                  ;DPTR = (4*pointer & RAMpages-1) + RAM
            RLC A
            MOV R3, A
            MOV A, @R0
            RLC A
            MOV R2, A
            MOV A, R3
            RLC A
            ANL A, 0C0H
            MOV DPL, A
            MOV A, R2
            RLC A
            ANL A, #RAMpages-1
            ADD A, #HIGH(RAM)
            MOV DPH, A
            RET

;Push T to the return stack
RDUPT:      MOV A, #RP                  ;{ RAM[--RP & (RAMsize-1)] = T; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
TTORAM:     MOV A, R4
            MOVX @DPTR, A
            INC DPTR
            MOV A, R5
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
            INC DPTR
            MOV A, R7
            MOVX @DPTR, A
            RET
;Drop T:N from data stack
SDROP:      MOV R4, N                   ;{ T = N;  N = RAM[VSP++ & (RAMsize-1)]; }
            MOV R5, N+1
            MOV R6, N+2
            MOV R7, N+3
SNIP:       MOV A, #VSP                  ;{ N = RAM[VSP++ & (RAMsize-1)]; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            MOV B, #N+3              ;pop to N

;pop stack using pointer[r0r1] to IRAM[B], primitive of both SDROP and RDROP
XNIP:       LCALL XPTR                  ;get DPTR
            MOV A, R0
            PUSH ACC                    ;keep R0
            MOV R0, B
            LCALL RAMTOR0               ;IRAM[B] = RAM[r0r1]
            POP ACC
            INC @R1                     ;IRAM[r0r1]++
            JNC XNIPX
            MOV R0, A
            INC @R0
XNIPX:      RET

;Drop from return stack, B points to destination VM register
RDROP:      MOV A, #RP                  ;{ IRAM[B] = RAM[RP++ & (RAMsize-1)]; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            SJMP XNIP

;Read XRAM to IRAM[R0] using current DPTR. Endianness: XRAM is LE, IRAM is BE.
RAMTOR0:    MOVX A, @DPTR               ;XRAM to @R0
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            RET

;Shift right VM register pointed to by R0 one place
CELLDIV2:   MOV A, @R0                  ;IRAM[R0] /= 2
            RLC A
            SJMP CELLXDIV2
PCDIV2:     MOV R0, #VPC                 ;VPC >>= 1
CELLUDIV2:  CLR C                       ;IRAM[R0] >>= 1
CELLXDIV2:  MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            RET

PCTIMES2:   MOV R0, #VPC+3               ;VPC <<= 1
CELLTIMES2: CLR C                       ;IRAM[R0] <<= 1
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            RET


;IMMmask = ~(-1<<slot)) where slot is 26, 20, 14, 8, or 2
IMMmasks:   DW 003FFH, 0FFFFH
            DW 0000FH, 0FFFFH
            DW 00000H, 03FFFH
            DW 00000H, 000FFH
            DW 00000H, 00003H

;IMM is IR & IMMmask. Place unsigned IMM in @R0
GetIMM:     MOV DPTR, #IMMmasks
            MOV A, SLOTID
            RLC A
            RLC A
            ANL A, #03CH
            MOV R1, A                   ;A is offset into IMMmasks table
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            RET

;-------------------------------------------------------------------------------
;Opcodes

opDUP:      LCALL SDUP
            LJMP NEXT

opEXIT:     MOV B, #VPC
            LCALL RDROP
            LCALL PCDIV2
            LCALL PCDIV2
            LJMP NEXT

opADDC:     MOV C, CARRY
            SJMP opADDX
opADD:      CLR C
opADDX:     MOV A, R7
            ADDC A, N+3
            MOV R7, A
            MOV A, R6
            ADDC A, N+2
            MOV R6, A
            MOV A, R5
            ADDC A, N+1
            MOV R5, A
            MOV A, R4
            ADDC A, N+0
            MOV R4, A
            MOV CARRY, C
            LCALL SNIP
            LJMP NEXT


opUSER:     MOV R0, #IR
            LCALL GetIMM                ;IR = immediate data
            LCALL CallImmFn
            LJMP EX

CallImmFn:  MOV DPTR, #ExtFnTable
            CLR A
            MOVC A, @A+DPTR             ;get size of table
            INC DPTR
            CLR C
            SUBB A, IR+3                ;lower 8 bits are function number
            JC CallImmFnX               ;Index must be in range
                MOV R0, N+3
                MOV R1, N+2
                MOV R2, N+1             ;load pointer from N
                MOV B, #3
                MOV A, IR+3
                MUL AB
                PUSH ACC
                MOV A, B
                ADD A, DPH
                MOV DPH, A
                POP ACC
                JMP @A+DPTR
CallImmFnX: RET

opZeroEquals:
            CLR A
            MOV A, R4
            ORL A, R5
            ORL A, R6
            ORL A, R7
            JZ opMakeFlag
            CLR A
            CPL A
            SJMP opMakeFlag
opZeroLess: MOV A, R4
            RLC A
            CLR A
            RLC A                       ;1 if T<0 else 0
            DEC A
opMakeFlag: CPL A                       ;0 -> TRUE, 255 -> FALSE
            MOV R7, A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            LJMP NEXT

opPOP:      LCALL SDUP
            MOV B, #Scratch
            LCALL RDROP
ScratchToTOS:
            MOV R4, Scratch
            MOV R5, Scratch+1
            MOV R6, Scratch+2
            MOV R7, Scratch+3
            LJMP NEXT

opUtwoDiv:  CLR C
            SJMP opTwoDiv1
opTwoDiv:   MOV A, R4
            RLC A                       ;signed right shift
opTwoDiv1:  MOV A, R4
            RRC A
            MOV R4, A
            MOV A, R5
            RRC A
            MOV R5, A
            MOV A, R6
            RRC A
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
qnext:      LJMP NEXT

opSKIPNC:   MOV C, CARRY
            JC qnext
opSKIP:     LJMP EX
opSKIPNZ:   MOV A, R4
            ORL A, R5
            ORL A, R6
            ORL A, R7
            JNZ opSKIP
            LJMP NEXT
opSKIPGE:   MOV A, R4
            RLC A
            JNC opSKIP
            LJMP NEXT
opSKIPLT:   MOV A, R4
            RLC A
            JC opSKIP
            LJMP NEXT

opFourPlus: MOV A, #4
            SJMP opXPlus
opTwoPlus:  MOV A, #2
            SJMP opXPlus
opOnePlus:  MOV A, #1
opXPlus:    ADD A, R7
            MOV R7, A
            MOV A, R6
            ADDC A, R6
            MOV R6, A
            CLR A
            ADDC A, R5
            MOV R5, A
            CLR A
            ADDC A, R4
            MOV R4, A
            LJMP NEXT

opSWAP:     MOV A, R4
            XCH A, N
            MOV R4, A
            MOV A, R5
            XCH A, N+1
            MOV R5, A
            MOV A, R6
            XCH A, N+2
            MOV R6, A
            MOV A, R7
            XCH A, N+3
            MOV R7, A
            LJMP NEXT

opSUB:      CLR C
            MOV A, N+3
            SUBB A, T+3
            MOV T+3, A
            MOV A, N+2
            SUBB A, T+2
            MOV T+2, A
            MOV A, N+1
            SUBB A, T+1
            MOV T+1, A
            MOV A, N
            SUBB A, T
            MOV T, A
            MOV CARRY, C
            LCALL SNIP
            LJMP NEXT

opJUMP:     MOV R0, #VPC
            LCALL GetIMM
            LJMP EX

FetchC:     ;r4r5r6r7 = VMmem[r4r5r6r7] 16-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROMC
            ADD A, #-RAMpages
            JNC FetchRAMC
            SJMP ClearT
FetchROMC:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            MOV R7, A
            CLR A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            RET
FetchRAMC:  MOV DPL, R7         ;RAM is page-aligned
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            MOV R7, A
            CLR A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            RET

FetchW:     ;r4r5r6r7 = VMmem[r4r5r6r7] 16-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROMW
            ADD A, #-RAMpages
            JNC FetchRAMW
            SJMP ClearT
FetchROMW:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R7, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOV R5, A
            MOV R4, A
            RET
FetchRAMW:  MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            INC DPTR
            MOV R7, A
            MOVX A, @DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOV R5, A
            MOV R4, A
            RET

FetchL:     ;r4r5r6r7 = VMmem[r4r5r6r7] 32-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROML
            ADD A, #-RAMpages
            JNC FetchRAML
ClearT:     CLR A
            MOV R4, A
            MOV R5, A
            MOV R6, A
            MOV R7, A
            RET
FetchROML:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R7, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R5, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R4, A
            RET
FetchRAML:  MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            INC DPTR
            MOV R7, A
            MOVX A, @DPTR
            INC DPTR
            MOV R6, A
            MOVX A, @DPTR
            INC DPTR
            MOV R5, A
            MOVX A, @DPTR
            INC DPTR
            MOV R4, A
            RET
SetROMaddr: MOV A, R7
            ADD A, #-LOW(ROMsize)
            MOV A, R6
            ADD A, #-HIGH(ROMsize)
            JC SetROMbad
            MOV DPTR, #ROM      ;ROM is anywhere in code space
            MOV A, #HIGH(ROM)   ;Add T to get base address in DPTR
            ADD A, R7
            MOV DPL, A
            MOV A, #LOW(ROM)
            ADD A, R6
            MOV DPH, A
            RET
SetROMbad:  MOV DPTR, #ROM      ;bad address reads from beginning of ROM
            RET

opCstorePlus:                   ;VMmem[r4r5r6r7] = r7
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreCnone      ;can't store to ROM
            ADD A, #-RAMpages
            JNC StoreC
            SJMP StoreCnone
StoreC:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
StoreCnone: LJMP opOnePlus      ;nothing to store

opWstorePlus:                   ;VMmem[r4r5r6r7] = r7r6
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreWnone
            ADD A, #-RAMpages
            JNC StoreW
            SJMP StoreWnone
StoreW:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
StoreWnone: LJMP opTwoPlus

opStorePlus:                    ;VMmem[r4r5r6r7] = r7r6r5r4
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreLnone
            ADD A, #-RAMpages
            JNC StoreL
            SJMP StoreLnone
StoreL:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
            INC DPTR
            MOV A, R5
            MOVX @DPTR, A
            INC DPTR
            MOV A, R4
            MOVX @DPTR, A
StoreLnone: LJMP opFourPlus

opCfetch:   LCALL FetchC
            LJMP NEXT
opCfetchPlus:
            LCALL SDUP
            LCALL FetchC
            MOV A, #1
            LCALL BumpN
            LJMP NEXT

opWfetch:   LCALL FetchW
            LJMP NEXT
opWfetchPlus:
            LCALL SDUP
            LCALL FetchW
            MOV A, #2
            LCALL BumpN
            LJMP NEXT

opFetch:    LCALL FetchL
            LJMP NEXT
opFetchPlus:
            LCALL SDUP
            LCALL FetchL
            MOV A, #4
            LCALL BumpN
            LJMP NEXT

opAND:      MOV A, R7
            ANL A, N+3
            MOV R7, A
            MOV A, R6
            ANL A, N+2
            MOV R6, A
            MOV A, R5
            ANL A, N+1
            MOV R5, A
            MOV A, R4
            ANL A, N
            MOV R4, A
            LCALL SNIP
            LJMP NEXT

opLitX:     ;T = (T<<24) | (IMM & 0xFFFFFF);
            MOV R0, #IR
            LCALL GetIMM
            MOV A, R7
            MOV R4, A
            MOV A, IR+1
            MOV R5, A
            MOV A, IR+2
            MOV R6, A
            MOV A, IR+3
            LJMP EX

opPUSH:     LCALL RDUPT
            LCALL SDROP         ;>r
            LJMP NEXT

opCALL:     LCALL PCTIMES2
            LCALL PCTIMES2
            MOV B, #VPC
            LCALL RDUP
            MOV R0, #VPC
            LCALL GetIMM
            LJMP EX

opXOR:      MOV A, R7
            XRL A, N+3
            MOV R7, A
            MOV A, R6
            XRL A, N+2
            MOV R6, A
            MOV A, R5
            XRL A, N+1
            MOV R5, A
            MOV A, R4
            XRL A, N
            MOV R4, A
            LCALL SNIP
            LJMP NEXT

opREPT:     CLR A
            MOV NEXTSLOT, A
            MOV SLOTID, A
            LJMP NEXT

opOVER:     MOV Scratch+0, N+0
            MOV Scratch+1, N+1
            MOV Scratch+2, N+2
            MOV Scratch+3, N+3
            LCALL SDUP
            MOV R4, Scratch+0
            MOV R5, Scratch+1
            MOV R6, Scratch+2
            MOV R7, Scratch+3
            LJMP NEXT

opTwoStarC: MOV C, CARRY
            SJMP opTwoStar1
opTwoStar:  CLR C
opTwoStar1: MOV A, R7
            RLC A
            MOV R7, A
            MOV A, R6
            RLC A
            MOV R6, A
            MOV A, R5
            RLC A
            MOV R5, A
            MOV A, R4
            RLC A
            MOV R4, A
            MOV CARRY, C
            LJMP NEXT


opMiREPT:   PUSH N+2
            MOV A, #1
            LCALL BumpN
            POP ACC
            RLC A
            JC opREPT
            LJMP NEXT

BumpN:      MOV R0, #N+3
BumpReg:    ADD A, @R0          ;Add A to [R0]
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            RET

opDROP:     LCALL SDROP
            LJMP NEXT

opUP:       MOV R0, #UP
            SJMP opXP
opRP:       MOV R0, #RP
            SJMP opXP
opSP:       MOV R0, #VSP
opXP:       MOV A, @R0          ;{T += (M + ROMsize)*4;}
            INC R0
            ADD A, #ROMpages    ;ROMsize/256
            MOV R2, A
            MOV A, @R0
            CLR C
            RLC A
            MOV R3, A           ;r2r3 = XP + ROMsize
            MOV A, R2
            RLC A
            MOV R2, A
            CLR C
            MOV A, R3
            RLC A
            MOV R3, A           ;r2r3 = (XP + ROMsize) << 2
            MOV A, R2
            RLC A
            MOV R2, A
            MOV A, R3
            ADD A, R7
            MOV R7, A
            MOV A, R2
            ADDC A, R6
            MOV R6, A
            CLR A
            ADDC A, R5
            MOV R5, A
            CLR A
            ADDC A, R4
            MOV R4, A
            LJMP NEXT


;not implemented
opStoreAS:
opFetchAS:  LJMP NEXT

opPORT:     MOV A, R4
            XCH A, DebugReg+0
            MOV R4, A
            MOV A, R5
            XCH A, DebugReg+0
            MOV R5, A
            MOV A, R6
            XCH A, DebugReg+0
            MOV R6, A
            MOV A, R7
            XCH A, DebugReg+0
            MOV R7, A
            LJMP NEXT

opLIT:      MOV R0, #IR
            LCALL GetIMM
            MOV R4, IR
            MOV R5, IR+1
            MOV R6, IR+2
            MOV R7, IR+3
            LJMP EX

TTOXP:      CLR C               ; r6r7 = (T>>2) & (RAMsize-1), assume RAMsize < 16K
            MOV A, R6
            RRC A
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
            CLR C
            MOV A, R6
            RRC A
            ANL A, #RAMpages-1
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
            RET

opSetRP:    MOV B, #RP
            SJMP SetXP
opSetUP:    MOV B, #UP       ;UP = (T>>2) & (RAMsize-1);
SetXP:      LCALL TTOXP
            MOV R0, B
            MOV A, R6
            MOV @R0, A
            INC R0
            MOV A, R7
            MOV @R0, A
            LCALL SDROP
            LJMP NEXT

opSetSP:    LCALL TTOXP
            MOV R0, #VSP
            MOV A, R6
            MOV @R0, A
            INC R0
            MOV A, R7
            MOV @R0, A
            LJMP NEXT

opRfetch:   LCALL SDUP
            MOV B, #Scratch
            LCALL RDROP
            LJMP ScratchToTOS

ROM:
DW 04C00H,00212H, 04C00H,00215H, 04FFFH,0FFFFH, 096B0H,09000H, 036B0H,09000H, 056B0H,09000H
DW 005ABH,08318H, 096B0H,09000H, 005ADH,08318H, 036B0H,09000H, 0FC90H,09000H, 0FC9FH,0C240H
DW 0FE1FH,0C240H, 09E70H,09000H, 068A1H,08A08H, 029A2H,08608H, 02A20H,09000H, 02AB0H,09000H
DW 02862H,09A28H, 069A0H,09000H, 01862H,08628H, 068A0H,09000H, 0186FH,08A68H, 02BE2H,09A08H
DW 0AEB0H,09000H, 08A20H,09000H, 068A1H,08A68H, 068A1H,08A1AH, 069A8H,0A218H, 01930H,0001AH
DW 0AEBAH,0C240H, 00520H,09000H, 00424H,00000H, 00700H,05FFEH, 005F0H,09000H, 07424H,00000H
DW 07DD0H,09000H, 07DD7H,04240H, 075D0H,09000H, 0FC91H,04240H, 0449EH,04003H, 0FD70H,09000H
DW 098ABH,08A08H, 0965AH,0C240H, 0C3F2H,05000H, 00900H,00000H, 0FCAFH,0D7FEH, 06824H,00000H
DW 069A2H,0860CH, 02868H,0C240H, 0FDAFH,0C918H, 089DCH,02B26H, 0AC24H,00000H, 0C130H,00032H
DW 00900H,00000H, 03824H,00000H, 0E400H,00004H, 0CAE0H,09000H, 0E400H,00008H, 0CAE0H,09000H
DW 0E400H,0000CH, 0EAEEH,04008H, 0C8B1H,0C708H, 00679H,0F2B8H, 02AB0H,09000H, 0E400H,0000AH
DW 0E400H,08218H, 096B0H,09000H, 0E400H,00010H, 0E400H,08218H, 096B0H,09000H, 0B900H,00000H
DW 0E4FFH,0FFFFH, 05C24H,00000H, 08A2FH,0C340H, 0C2BAH,0EB08H, 0ACAFH,0C918H, 084A6H,08A68H
DW 06824H,00000H, 01862H,04688H, 08834H,00000H, 0C2B6H,09A6AH, 0AEBAH,0E16AH, 018A1H,0A20CH
DW 0FA20H,0CA68H, 02857H,0D000H, 0C2B6H,08240H, 0AC6AH,0C6ACH, 085A0H,09000H, 0E400H,0000CH
DW 0AAE0H,09000H, 0186AH,0C6ACH, 06824H,00000H, 08A27H,0DD40H, 04AB0H,09000H, 0AEB1H,0A16AH
DW 0186FH,0C9FCH, 0C2B6H,08240H, 06A16H,08240H, 01813H,083E7H, 005A0H,0C6FCH, 05DA0H,09000H
DW 08A27H,0C540H, 048B1H,04240H, 02AB1H,04240H, 02930H,00066H, 08A27H,0C540H, 048B1H,04240H
DW 0AC50H,09000H, 02930H,0006AH, 0FC9FH,0D000H, 0C130H,00073H, 0FC92H,09A28H, 09869H,05AA0H
DW 01ABAH,0EB08H, 0AEBAH,0C240H, 0FC9FH,0D000H, 0C130H,00079H, 0FC92H,09A28H, 03863H,05AA0H
DW 01ABAH,0EB08H, 0AEBAH,0C240H, 0FC9FH,0D000H, 0C130H,00083H, 02416H,08328H, 0F832H,086FCH
DW 02500H,00000H, 06BF2H,07F28H, 0FC9FH,0CA88H, 0DA23H,06B18H, 02704H,0C07FH, 0AEBAH,0C240H
DW 06A28H,09B66H, 04930H,00088H, 019B0H,0007AH, 04C00H,00089H, 019B0H,00074H, 00900H,00000H
DW 08924H,0C08FH, 02BF2H,04928H, 068A4H,00000H, 0F8A3H,06818H, 0AEBAH,0C240H, 0AEBAH,0C240H
DW 0FC9FH,0F0AEH, 0E400H,0003FH, 05FF2H,04A40H, 09E82H,0AB08H, 00900H,00000H, 0FC9FH,0F0AEH
DW 0E400H,0003FH, 05FF2H,04A40H, 03E82H,0AB08H, 00900H,00000H, 00417H,0F91FH, 0FD00H,00000H
DW 06A76H,0AF40H, 02221H,08368H, 02094H,00000H, 01862H,05000H, 0C130H,0009CH, 0ADA6H,0AB18H
DW 018A0H,09000H, 08A22H,0EB40H, 02130H,000A7H, 0AEBAH,0F900H, 0FC10H,09000H, 0E400H,0001FH
DW 0FCF9H,0D000H, 069A6H,0AF18H, 0BC84H,0C0AFH, 007E2H,0EB40H, 02130H,000AEH, 0F8B4H,00000H
DW 04C00H,000B1H, 0F8BEH,04000H, 09EB4H,00000H, 01862H,05000H, 0C130H,000A9H, 0AEB2H,0AFFEH
DW 08A27H,0DA88H, 069B0H,0002CH, 069B0H,00035H, 019B0H,000A3H, 02861H,05000H, 04930H,000BBH
DW 0FC94H,00000H, 02861H,05000H, 04930H,000BEH, 0FC94H,00000H, 00900H,00000H, 005A8H,0A27CH
DW 06816H,09B2CH, 069B0H,00035H, 019B0H,000A3H, 02861H,05000H, 04930H,000C6H, 0FC94H,00000H
DW 02861H,05000H, 04930H,000CCH, 0FC98H,09000H, 04930H,000CCH, 0F9A2H,08628H, 02CAFH,0C9FCH
DW 01AB0H,09000H, 00450H,05A40H, 04930H,000D1H, 0FC96H,09B32H, 01900H,00000H, 06811H,05000H
DW 04930H,000D4H, 0F834H,00000H, 019B0H,000A3H, 01924H,0C0D7H, 02BF2H,04A40H, 00900H,00000H
DW 08852H,093CDH, 06C00H,000D8H, 0AC24H,00000H, 06C00H,000D8H, 02AB0H,09000H, 08A26H,0C06AH
DW 048A4H,00000H, 0AC24H,00000H, 08A22H,09B6AH, 048A4H,00000H, 0AC24H,00000H, 08A26H,0C066H
DW 048A4H,00000H, 0AC24H,00000H, 08A22H,09B66H, 048A4H,00000H, 0AC24H,00000H, 068AFH,08328H
DW 018B0H,09000H, 088B6H,08B18H, 04C00H,00066H, 06C00H,0009AH, 0AC24H,00000H, 08A27H,0C568H
DW 06C00H,0002CH, 029B0H,0002CH, 06C00H,0009AH, 01924H,0C0F5H, 06C00H,00032H, 00900H,00000H
DW 069B0H,000EFH, 01930H,000CDH, 06C00H,000F6H, 02AB0H,09000H, 01000H,00006H, 00900H,00000H
DW 089AEH,04004H, 0C9A4H,00000H, 0E400H,08214H, 0B9AEH,04000H, 0AB90H,08214H, 096B6H,0C02FH
DW 01B90H,08214H, 096B1H,0AB19H, 07C24H,00000H, 0052AH,0C240H, 0E400H,08214H, 0BAD1H,09000H
DW 0E400H,08214H, 096B1H,08A68H, 0D6B2H,0AB18H, 018A0H,09000H, 00900H,00000H, 00900H,00000H
DW 00440H,00004H, 00900H,00000H, 0E400H,0000AH, 06C00H,000EDH, 06C00H,0010EH, 00D00H,00000H
DW 06C00H,0010CH, 005B0H,0010EH, 06C00H,0006AH, 04930H,00114H, 0AC24H,00000H, 06C00H,0010CH
DW 00440H,00003H, 04930H,00119H, 01000H,00002H, 0AC24H,00000H, 04C00H,0015CH, 03930H,0011EH
DW 0040AH,00D02H, 04A32H,05B1BH, 0E400H,00480H, 04C00H,0011FH, 0E400H,00483H, 04C00H,0011FH
DW 00440H,00000H, 00900H,00000H, 00440H,00001H, 00900H,00000H, 00000H,00464H, 00000H,00488H
DW 00000H,00490H, 00000H,00498H, 00000H,004A0H, 0E400H,004A8H, 0E400H,08230H, 096B0H,09000H
DW 09E74H,00000H, 0E400H,08230H, 0B83BH,09A08H, 0E400H,00000H, 04C00H,00132H, 0E400H,00001H
DW 04C00H,00132H, 0E400H,00002H, 04C00H,00132H, 0E400H,00003H, 04C00H,00132H, 0E400H,00004H
DW 04C00H,00132H, 089AFH,0C9FCH, 02892H,086DAH, 0E400H,00006H, 06C00H,00090H, 069B0H,0013FH
DW 0E400H,0003FH, 05C60H,0C240H, 06C00H,0013FH, 00790H,000C0H, 05F90H,00080H, 07DD4H,00000H
DW 04930H,0014CH, 0AD30H,00146H, 00790H,00080H, 05D24H,0C15BH, 00790H,00020H, 05D24H,0C159H
DW 00790H,00010H, 05D24H,0C156H, 0E400H,00007H, 05DB0H,00141H, 06C00H,00141H, 04C00H,00141H
DW 0E400H,0000FH, 05DB0H,00141H, 04C00H,00141H, 0E400H,0001FH, 05D30H,00141H, 00900H,00000H
DW 007F2H,07F14H, 0FD24H,0C161H, 06C00H,00146H, 06C00H,00135H, 04C00H,0015CH, 0AEB0H,09000H
DW 0E400H,00020H, 04C00H,00135H, 0C2B0H,09000H, 06C00H,00162H, 0FC9FH,0D000H, 04C00H,00164H
DW 00900H,00000H, 0E400H,00009H, 089B0H,0006AH, 0E400H,00007H, 05C3EH,04030H, 00C24H,00000H
DW 0E400H,08354H, 0E400H,08288H, 096B0H,09000H, 0E400H,08288H, 0BBF2H,07F04H, 0E400H,08288H
DW 096B3H,06B08H, 0E400H,00000H, 0E400H,08218H, 0B9B0H,000A3H, 06B90H,08218H, 0B9B0H,000A3H
DW 029B0H,00169H, 06C00H,00171H, 01824H,00000H, 06C00H,00175H, 08A26H,0C02EH, 07524H,0C17DH
DW 00900H,00000H, 01524H,0C184H, 0E400H,0002DH, 06C00H,00171H, 00900H,00000H, 0AEB4H,00000H
DW 0E400H,08288H, 0BB90H,08354H, 088B0H,09000H, 088B6H,0C164H, 04C00H,0011EH, 06816H,09B35H
DW 06C00H,0016EH, 06C00H,0017DH, 019B0H,00181H, 06C00H,00185H, 01930H,00189H, 0E400H,00000H
DW 02930H,0018BH, 069B0H,00021H, 01930H,0018BH, 0E400H,00000H, 06C00H,0018BH, 04C00H,00162H
DW 0E400H,00000H, 04C00H,00195H, 0E400H,08218H, 0BB90H,0000AH, 07D24H,0C19EH, 04C00H,00198H
DW 06C00H,00021H, 04C00H,00195H, 0B930H,0019AH, 06C00H,0016EH, 0FC94H,00000H, 069B0H,00175H
DW 01894H,00000H, 0C130H,001A3H, 0ADB0H,0017DH, 04C00H,00185H, 0E400H,08218H, 0B9A6H,0C044H
DW 0E400H,00000H, 029B0H,001A1H, 01B90H,08218H, 096B6H,0C11EH, 04C00H,00162H, 06C00H,0010CH
DW 06C00H,0013BH, 04930H,001AFH, 06C00H,0013DH, 00790H,0000DH, 07DD4H,00000H, 04930H,001B8H
DW 0AF90H,00000H, 0FC24H,00000H, 00790H,00020H, 06C00H,0006AH, 04930H,001BDH, 0AF90H,00000H
DW 00900H,00000H, 0E400H,0824EH, 0D9D4H,00000H, 04930H,001C1H, 005B0H,00135H, 00900H,00000H
DW 02A24H,00000H, 00524H,0C1CBH, 069B0H,001AFH, 0C2BAH,0C62EH, 06C00H,0001FH, 04930H,001C9H
DW 028D4H,00000H, 01BF2H,07F40H, 04C00H,001C3H, 0AEB0H,09000H, 04C00H,001D0H, 06C65H,0480BH
DW 05720H,06F6CH, 0646CH,0726FH, 0E400H,00734H, 039B0H,0011EH, 06C00H,00137H, 0E400H,0000AH
DW 0E400H,00000H, 02BF2H,05A68H, 0F9B0H,0019AH, 06C00H,0004FH, 04C00H,001D6H, 00900H,00000H
DW 00000H,00004H, 00000H,08204H, 00000H,08200H, 00000H,081F0H, 00000H,08100H, 00000H,00000H
DW 00000H,00005H, 00000H,08218H, 00000H,0000AH, 00000H,09B48H, 00000H,00768H, 00000H,08354H
DW 00000H,00000H, 00000H,00004H, 00000H,0822CH, 00000H,08284H, 00000H,004A8H, 00000H,00001H
DW 00000H,00000H, 00000H,00002H, 00000H,0823CH, 00000H,0828CH, 00000H,00000H, 00000H,00002H
DW 00000H,08248H, 0001AH,00001H, 00000H,00000H, 00000H,00002H, 00000H,08250H, 01A00H,00760H
DW 00000H,00000H, 00000H,00004H, 00000H,0825CH, 00000H,08A58H, 00004H,00003H, 00000H,08284H
DW 00000H,00000H, 00000H,00002H, 00000H,08284H, 00000H,09B28H, 00000H,00000H, 00000H,00000H
DW 0E400H,00768H, 09A28H,0899CH, 09C32H,09A28H, 01814H,00000H, 04930H,0020BH, 06A61H,09B6EH
DW 04C00H,00205H, 01B90H,08288H, 096B4H,00000H, 0E400H,08200H, 0F790H,08100H, 0D790H,081ECH
DW 0B790H,08288H, 0B9A0H,09000H, 06C00H,00204H, 06C00H,001CCH, 04C00H,000FAH, 06C00H,00204H
DW 06C00H,001CCH, 04C00H,000FAH


END


#include <stdio.h>
#include <stdlib.h>
#include "vm.h"
#include "vmaccess.h"
#include <string.h>
#include <time.h>

#define C_Columns  6                    /* Number of columns in C ROM generation */

char * GetTime(void) {                  // get time/date string
    time_t current_time;
    char* c_time_string;
    current_time = time(NULL);              /* Obtain current time. */
    c_time_string = ctime(&current_time);   /* Convert to local time format. */
    return c_time_string;
}
// Load a ROM image file

char* LoadedFilename;                   // saved filename and format
int LoadedFileType;

int BinaryLoad (char* filename) {       // Load ROM from binary file
    FILE *fp;
    uint8_t data[4];
    int length, i;
    uint32_t n;
    uint32_t addr = 0;
    fp = fopen(filename, "rb");
    if (!fp) { return -1; }             // bad filename
    LoadedFilename = filename;          // save in case we want to reload the file
    LoadedFileType = 1;
    do {
        memset(data, 255, 4);
        length = fread(data, 1, 4, fp); // get 4 bytes of data
        n = 0;
        for (i = 0; i < 4; i++) {       // make little-endian word
            n += data[i] << (8 * i);
        }
        WriteROM(n, addr);              // ignore ior
        addr += 4;
    } while (length == 4);
    fclose(fp);
    return 0;
}

void ReloadFile (void) {                // Reload known ROM image file
    switch(LoadedFileType) {
        case 1: BinaryLoad(LoadedFilename);
        default: break;
    }
}

uint32_t rom[ROMsize+SPIflashSize];

int32_t ROMwords (uint32_t size) {     // read ROM image to local memory
    uint32_t i;
    for (i=0; i<size; i++) {            // fill rom for local processing
        rom[i] = FetchCell(i*4);        // read through the VM's debug interface
    }
    i = size;
    while (--i) {
        if (rom[i] != 0xFFFFFFFF) break; // find the last non-blank word
    }
    return i+1;
}

/*
Internal ROM is a static array of size ROMsize defined in `config.f`.
It will have blanks (FFFFFFFF) for unused area. These are included in the table.
*/

void SaveROMasC (char *filename) {      // save internal ROM in C format
    int32_t i;
    FILE *ofp;
    ofp = fopen(filename, "w");
    if (ofp == NULL) {
        tiffIOR = -198;                 // Can't create output file
        return;
    }
    // Generate C text
    fprintf(ofp, "#include <stdint.h>\n");
    fprintf(ofp, "#define ROMsize %d\n\n", ROMsize);
    fprintf(ofp, "// Internal ROM of VM\n");
    fprintf(ofp, "// Generated by tiff.exe, save-rom, %s\n", GetTime());
    fprintf(ofp, "static uint32_t ROM[ROMsize] {");

    for (i=0; i<ROMsize; i++) {
        if (i % C_Columns) {
            fprintf(ofp, " ");
        } else {
            fprintf(ofp, "\n/*%04X*/ ", i);
        }
        fprintf(ofp, "0x%08X", FetchCell(i*4));
        if (i != (ROMsize-1)) {
            fprintf(ofp, ",");
        }
    }
    fprintf(ofp, "};\n");
    fclose(ofp);
}

// Alignment must be a power of two.
// The array will be padded to be sized as a multiple of alignment in cells.

/*
SPI ROM is either simulated, as in the case of a PC app, or in MCU hardware.
In the latter case, the MCU can keep it internal or external.
If it's internal, you would place a static array with linker file tricks.
If it's external, you need a way to program it into SPI flash in production.
*/


void SaveAXIasC (char *filename, int alignment) {      // save Flash in C format
    int32_t length = ROMwords(SPIflashSize); // end of AXI data
            length = (length + alignment - 1) & (-alignment);
    int32_t i;  int32_t offset;
    FILE *ofp;
    ofp = fopen(filename, "w");
    if (ofp == NULL) {
        tiffIOR = -198;                 // Can't create output file
        return;
    }
    // Generate C text
    fprintf(ofp, "#include <stdint.h>\n");
#ifdef BootFromSPI
    fprintf(ofp, "#define FlashSize %d\n", length);
    fprintf(ofp, "#define FlashOrigin 0 /* Boot+Headers */\n");
    offset = 0;
#else
    fprintf(ofp, "#define FlashSize %d\n", length);
    fprintf(ofp, "#define FlashOrigin 0x%X /* Headers */\n", HeadPointerOrigin);
    offset = HeadPointerOrigin / 4;
#endif
    fprintf(ofp, "#define HeaderOrigin 0x%X\n\n", HeadPointerOrigin);
    fprintf(ofp, "// SPI flash image, padded to 4KB sector size\n");
    fprintf(ofp, "// Generated by tiff.exe, save-flash, %s\n", GetTime());
    fprintf(ofp, "static uint32_t FlashData[] {");

    for (i=offset; i<length; i++) {
        if (i % C_Columns) {
            fprintf(ofp, " ");
        } else {
            fprintf(ofp, "\n");
        }
        fprintf(ofp, "0x%08X", rom[i]);
        if (i != (length-1)) {
            fprintf(ofp, ",");
        }
    }
    fprintf(ofp, "};\n");
    fclose(ofp);
}

;32-bit Virtual Machine and application ROM for 8051, flavor SiLabs EFM8LB1.
;STATUS: Assembles without errors but UNTESTED

;This file was generated by Tiff using template.A51 -- don't edit this file.

;The VM model interfaces with Keil C51 C functions, which use R4R5R6R7 as the
;return value as well as the _long_ non-pointer first parameter.
;The first pointer parameter is R2R1R0. User functions pass N to this.

$NOMOD51
#include "SI_EFM8LB1_Defs.inc"
XRAMsize    EQU 1000H                  ;XRAM size of MCU in bytes

;The VM's USER function is free to trash the registers since it's the last
;executed slot. Otherwise, the VM uses R0-R3 as scratchpad.
;The RAM (with RAMsize 32-bit words) is implemented in XRAM.
;XRAMsize is used to place the VM's RAM at the top of XRAM. The linker will see it.

ROMsize     EQU `2`*4 ;bytes in ROM (at end of this file)
RAMbase     EQU (`3` >> 6) ;base address of RAM / 256

;-------------------------------------------------------------------------------
;The Keil C51/A51 compiler (assembled code/data) is big endian.
;The VM (code, stack and data space) is little endian.
;IRAM data is big endian, XRAM (and all other) data is little endian.

            NAME VMstuff

            PUBLIC _VMstep              ;uint32_t VMstep(uint32_t IR);
            PUBLIC VMpor                ;void VMpor(void);
            PUBLIC SetDbgReg            ;void SetDbgReg(uint32_t n);
            PUBLIC _GetDbgReg           ;uint32_t GetDbgReg(void);
            PUBLIC _vmRegRead           ;uint32_t vmRegRead(int id);

ExtFnTable  EQU 0x00A0

;Absolute XDATA is used for the RAM of the VM.
            XSEG AT XRAMsize - (4*`4`)
RAM:        DS 4*`4`
;Size is assumed to be a power-of-2 multiple of 256-byte pages in size.
;This allows a byte-wide bit mask to wrap the RAM address.
RAMpages    EQU (`4` >> 6)
ROMpages    EQU (`3` >> 6)


?ID?VM      SEGMENT DATA                ;Direct RAM
?BI?VM      SEGMENT BIT                 ;Bit space
?PR?VM      SEGMENT CODE                ;Code space

            RSEG ?ID?VM

;PC and SP are reserved symbols, put a V in front.
T:          DS 4                        ;top of stack
N:          DS 4                        ;next on stack
VPC:        DS 4                        ;program counter
DebugReg:   DS 4
IR:         DS 4                        ;instruction register
RP:         DS 2                        ;return stack pointer = 64
VSP:        DS 2                        ;return stack pointer = 32
UP:         DS 2                        ;return stack pointer = 64
Scratch:    DS 7                        ;scratchpad storage
NEXTSLOT:   DS 1                        ;state for slot jump
SLOTID:     DS 1                        ;slot ID for IMM mask lookup

            RSEG ?BI?VM
CARRY:      DBIT 1                      ;carry flag

;-------------------------------------------------------------------------------

            RSEG ?PR?VM					;code is ~2kB plus ROM size
            USING 0
;void SetDbgReg(uint32_t n);            ;write to the debug mailbox
SetDbgReg:  MOV DebugReg+0, R4
            MOV DebugReg+1, R5
            MOV DebugReg+2, R6
            MOV DebugReg+3, R7
            RET

;uint32_t GetDbgReg(void);              ;read from the debug mailbox
_GetDbgReg: MOV R4, DebugReg+0
            MOV R5, DebugReg+1
            MOV R6, DebugReg+2
            MOV R7, DebugReg+3
            RET

VMinitTable:
            DW RAM+64, RAM+32, RAM+64   ;registers for VM

;void VMpor(void);                      ;initialize the VM
VMpor:      MOV R0, #T                  ;-> first Direct RAM
            MOV R1, #16
            CLR A
VMpor0:         MOV @R0, A              ;clear first 4 longs
                INC R0
                DJNZ R1, VMpor0
            MOV DPTR, #VMinitTable
            MOV R1, #6
VMpor1:         CLR A                   ;load 3 halfwords from table
                MOVC A, @A+DPTR
                INC DPTR
                MOV @R0, A
                INC R0
                DJNZ R1, VMpor1
            MOV DPTR, #RAM              ;clear all of RAM
            MOV R2, #RAMpages
            CLR A
VMpor2:         MOVX @DPTR, A           ;clear page
                DJNZ R1, VMpor1
                DJNZ R2, VMpor1
            RET

;-------------------------------------------------------------------------------

;uint32_t VM(uint32_t IR); IR is in r4r5r6r7.
_VM:        MOV IR, R4                  ;execute an instruction group
            MOV IR+1, R5
            MOV IR+2, R6
            MOV IR+3, R7
            MOV R4, T
            MOV R5, T+1
            MOV R6, T+2
            MOV R7, T+3
            CLR A
            MOV NEXTSLOT, A
            MOV SLOTID, A
            INC VPC+3                    ;VPC++
            JNC NEXT
            INC VPC+2
            JNC NEXT
            INC VPC+1
            JNC NEXT
            INC VPC
NEXT:	    MOV DPTR, #SLOT0
            MOV A, NEXTSLOT
            JMP @A+DPTR
SLOT0:      MOV A, IR
            RRC A
            RRC A
            MOV NEXTSLOT, #SLOT1-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT1:      MOV A, IR+1
            SWAP A
            ANL A, #0FH
            MOV R0, A
            MOV A, IR
            SWAP A
            ANL A, #30H
            ORL A, R0
            MOV NEXTSLOT, #SLOT2-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT2:      MOV A, IR+1
            RLC A
            RLC A
            ANL A, #3CH
            MOV R0, A
            MOV A, IR+2
            RRC A
            RRC A
            SWAP A
            ANL A, #3
            ORL A, R0
            MOV NEXTSLOT, #SLOT3-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT3:	    MOV A, IR+2
            MOV NEXTSLOT, #SLOT4-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT4:	    MOV A, IR+3
            RRC A
            RRC A
            MOV NEXTSLOT, #SLOT5-SLOT0
            INC SLOTID
            SJMP DISPATCH
SLOT5:      MOV A, IR+3
            ANL A, #3
            MOV NEXTSLOT, #SLOT6-SLOT0
            INC SLOTID
            SJMP DISPATCH
EX:
SLOT6:      MOV T, R4
            MOV T+1, R5
            MOV T+2, R6
            MOV T+3, R7
            MOV R4, VPC
            MOV R5, VPC+1
            MOV R6, VPC+2
            MOV R7, VPC+3
            RET
;64-way jump uses a table of LJMP to functions. All functions jump to NEXT.
DISPATCH:   ;ACC = ??oooooo where oooooo is a 6-bit opcode
            ANL A, #63
            MOV R3, A
            ADD A, ACC
            ADD A, R3
            MOV DPTR, #JumpTable
            JMP @A+DPTR

JumpTable:  LJMP NEXT         ;(000)  // nop
            LJMP opDUP        ;(001)  // dup
            LJMP opEXIT       ;(002)  // exit
            LJMP opADD        ;(003)  // +
            LJMP opUSER       ;(004)  // user
            LJMP opZeroLess   ;(005)  // 0<
            LJMP opPOP        ;(006)  // r>
            LJMP opTwoDiv     ;(007)  // 2/

            LJMP opSKIPNC     ;(010)  // ifc:  slot=end if no carry
            LJMP opOnePlus    ;(011)  // 1+
            LJMP opSWAP       ;(012)  // swap
            LJMP opSUB        ;(013)  // -
            LJMP NEXT
            LJMP opCstorePlus ;(015)  // c!+  ( c a -- a+1 )
            LJMP opCfetchPlus ;(016)  // c@+  ( a -- a+1 c )
            LJMP opUtwoDiv    ;(017)  // u2/

            LJMP opSKIP       ;(020)  // no:  skip remaining slots
            LJMP opTwoPlus    ;(021)  // 2+
            LJMP opSKIPNZ     ;(022)  // ifz:
            LJMP opJUMP       ;(023)  // jmp
            LJMP NEXT
            LJMP opWstorePlus ;(025)  // w!+  ( n a -- a+2 )
            LJMP opWfetchPlus ;(026)  // w@+  ( a -- a+2 n )
            LJMP opAND        ;(027)  // and

            LJMP NEXT
            LJMP opLitX       ;(031)  // litx
            LJMP opPUSH       ;(032)  // >r
            LJMP opCALL       ;(033)  // call
            LJMP NEXT
            LJMP opZeroEquals ;(035)  // 0=
            LJMP opWfetch     ;(036)  // w@  ( a -- n )
            LJMP opXOR        ;(037)  // xor

            LJMP opREPT       ;(040)  // rept  slot=0
            LJMP opFourPlus   ;(041)  // 4+
            LJMP opOVER       ;(042)  // over
            LJMP opADDC       ;(043)  // c+  with carry in
            LJMP NEXT
            LJMP opStorePlus  ;(045)  // !+  ( n a -- a+4 )
            LJMP opFetchPlus  ;(046)  // @+  ( a -- a+4 n )
            LJMP opTwoStar    ;(047)  // 2*

            LJMP opMiREPT     ;(050)  // -rept  slot=0 if T < 0
            LJMP NEXT
            LJMP opRP         ;(052)  // rp
            LJMP opDROP       ;(053)  // drop
            LJMP NEXT
            LJMP opSetRP      ;(055)  // rp!
            LJMP opFetch      ;(056)  // @
            LJMP opTwoStarC   ;(057)  // 2*c

            LJMP opSKIPGE     ;(060)  // -if:  slot=end if T >= 0
            LJMP NEXT
            LJMP opSP         ;(062)  // sp
            LJMP opFetchAS    ;(063)  // @as
            LJMP opSetSP      ;(065)  // sp!
            LJMP opCfetch     ;(066)  // c@
            LJMP opPORT       ;(067)  // port  ( n -- m ) swap T with port

            LJMP opSKIPLT     ;(070)  // +if:  slot=end if T < 0
            LJMP opLIT        ;(071)  // lit
            LJMP opUP         ;(072)  // up
            LJMP opStoreAS    ;(073)  // !as
            LJMP NEXT
            LJMP opSetUP      ;(075)  // up!
            LJMP opRfetch     ;(076)  // r@
;           LJMP opCOM        ;(077)  // com
            MOV A, R7
            CPL A
            MOV R7, A
            MOV A, R6
            CPL A
            MOV R6, A
            MOV A, R5
            CPL A
            MOV R5, A
            MOV A, R4
            CPL A
            MOV R4, A
            LJMP NEXT

;Common stack operations are the same as in the C model.
;The stack pointers are indices to longs. RAMsize is in longs.

SDUP:       MOV A, #VSP                  ;{ RAM[--VSP & (RAMsize-1)] = N;  N = T; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
            MOV R0, #N+3
            LCALL R0TORAM               ;write N to XRAM
            MOV N, R4
            MOV N+1, R5
            MOV N+2, R6
            MOV N+3, R7
            RET

;Push IRAM[B] to the return stack
RDUP:       MOV A, #RP                  ;{ RAM[--RP & (RAMsize-1)] = B; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
            MOV R0, B                ;write x to XRAM
R0TORAM:    MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            INC DPTR
            MOV A, @R0
            DEC R0
            MOVX @DPTR, A
            RET

XDUP:       MOV A, @R0                  ;predecrement pointer
            JNZ XDUP0
            DEC @R0
XDUP0:      DEC @R1

XPTR:       MOV A, @R1                  ;DPTR = (4*pointer & RAMpages-1) + RAM
            RLC A
            MOV R3, A
            MOV A, @R0
            RLC A
            MOV R2, A
            MOV A, R3
            RLC A
            ANL A, 0C0H
            MOV DPL, A
            MOV A, R2
            RLC A
            ANL A, #RAMpages-1
            ADD A, #HIGH(RAM)
            MOV DPH, A
            RET

;Push T to the return stack
RDUPT:      MOV A, #RP                  ;{ RAM[--RP & (RAMsize-1)] = T; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            LCALL XDUP                  ;get DPTR
TTORAM:     MOV A, R4
            MOVX @DPTR, A
            INC DPTR
            MOV A, R5
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
            INC DPTR
            MOV A, R7
            MOVX @DPTR, A
            RET
;Drop T:N from data stack
SDROP:      MOV R4, N                   ;{ T = N;  N = RAM[VSP++ & (RAMsize-1)]; }
            MOV R5, N+1
            MOV R6, N+2
            MOV R7, N+3
SNIP:       MOV A, #VSP                  ;{ N = RAM[VSP++ & (RAMsize-1)]; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            MOV B, #N+3              ;pop to N

;pop stack using pointer[r0r1] to IRAM[B], primitive of both SDROP and RDROP
XNIP:       LCALL XPTR                  ;get DPTR
            MOV A, R0
            PUSH ACC                    ;keep R0
            MOV R0, B
            LCALL RAMTOR0               ;IRAM[B] = RAM[r0r1]
            POP ACC
            INC @R1                     ;IRAM[r0r1]++
            JNC XNIPX
            MOV R0, A
            INC @R0
XNIPX:      RET

;Drop from return stack, B points to destination VM register
RDROP:      MOV A, #RP                  ;{ IRAM[B] = RAM[RP++ & (RAMsize-1)]; }
            MOV R0, A                   ;-> high byte
            INC A
            MOV R1, A                   ;-> low byte
            SJMP XNIP

;Read XRAM to IRAM[R0] using current DPTR. Endianness: XRAM is LE, IRAM is BE.
RAMTOR0:    MOVX A, @DPTR               ;XRAM to @R0
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            DEC R0
            MOVX A, @DPTR
            INC DPTR
            MOV @R0, A
            RET

;Shift right VM register pointed to by R0 one place
CELLDIV2:   MOV A, @R0                  ;IRAM[R0] /= 2
            RLC A
            SJMP CELLXDIV2
PCDIV2:     MOV R0, #VPC                 ;VPC >>= 1
CELLUDIV2:  CLR C                       ;IRAM[R0] >>= 1
CELLXDIV2:  MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            INC R0
            MOV A, @R0
            RRC A
            MOV @R0, A
            RET

PCTIMES2:   MOV R0, #VPC+3               ;VPC <<= 1
CELLTIMES2: CLR C                       ;IRAM[R0] <<= 1
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            DEC R0
            MOV A, @R0
            RLC A
            MOV @R0, A
            RET


;IMMmask = ~(-1<<slot)) where slot is 26, 20, 14, 8, or 2
IMMmasks:   DW 003FFH, 0FFFFH
            DW 0000FH, 0FFFFH
            DW 00000H, 03FFFH
            DW 00000H, 000FFH
            DW 00000H, 00003H

;IMM is IR & IMMmask. Place unsigned IMM in @R0
GetIMM:     MOV DPTR, #IMMmasks
            MOV A, SLOTID
            RLC A
            RLC A
            ANL A, #03CH
            MOV R1, A                   ;A is offset into IMMmasks table
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            INC R0
            INC R1
            MOV A, R1
            MOVC A, @A+DPTR
            ANL A, @R0
            MOV @R0, A
            RET

;-------------------------------------------------------------------------------
;Opcodes

opDUP:      LCALL SDUP
            LJMP NEXT

opEXIT:     MOV B, #VPC
            LCALL RDROP
            LCALL PCDIV2
            LCALL PCDIV2
            LJMP NEXT

opADDC:     MOV C, CARRY
            SJMP opADDX
opADD:      CLR C
opADDX:     MOV A, R7
            ADDC A, N+3
            MOV R7, A
            MOV A, R6
            ADDC A, N+2
            MOV R6, A
            MOV A, R5
            ADDC A, N+1
            MOV R5, A
            MOV A, R4
            ADDC A, N+0
            MOV R4, A
            MOV CARRY, C
            LCALL SNIP
            LJMP NEXT


opUSER:     MOV R0, #IR
            LCALL GetIMM                ;IR = immediate data
            LCALL CallImmFn
            LJMP EX

CallImmFn:  MOV DPTR, #ExtFnTable
            CLR A
            MOVC A, @A+DPTR             ;get size of table
            INC DPTR
            CLR C
            SUBB A, IR+3                ;lower 8 bits are function number
            JC CallImmFnX               ;Index must be in range
                MOV R0, N+3
                MOV R1, N+2
                MOV R2, N+1             ;load pointer from N
                MOV B, #3
                MOV A, IR+3
                MUL AB
                PUSH ACC
                MOV A, B
                ADD A, DPH
                MOV DPH, A
                POP ACC
                JMP @A+DPTR
CallImmFnX: RET

opZeroEquals:
            CLR A
            MOV A, R4
            ORL A, R5
            ORL A, R6
            ORL A, R7
            JZ opMakeFlag
            CLR A
            CPL A
            SJMP opMakeFlag
opZeroLess: MOV A, R4
            RLC A
            CLR A
            RLC A                       ;1 if T<0 else 0
            DEC A
opMakeFlag: CPL A                       ;0 -> TRUE, 255 -> FALSE
            MOV R7, A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            LJMP NEXT

opPOP:      LCALL SDUP
            MOV B, #Scratch
            LCALL RDROP
ScratchToTOS:
            MOV R4, Scratch
            MOV R5, Scratch+1
            MOV R6, Scratch+2
            MOV R7, Scratch+3
            LJMP NEXT

opUtwoDiv:  CLR C
            SJMP opTwoDiv1
opTwoDiv:   MOV A, R4
            RLC A                       ;signed right shift
opTwoDiv1:  MOV A, R4
            RRC A
            MOV R4, A
            MOV A, R5
            RRC A
            MOV R5, A
            MOV A, R6
            RRC A
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
qnext:      LJMP NEXT

opSKIPNC:   MOV C, CARRY
            JC qnext
opSKIP:     LJMP EX
opSKIPNZ:   MOV A, R4
            ORL A, R5
            ORL A, R6
            ORL A, R7
            JNZ opSKIP
            LJMP NEXT
opSKIPGE:   MOV A, R4
            RLC A
            JNC opSKIP
            LJMP NEXT
opSKIPLT:   MOV A, R4
            RLC A
            JC opSKIP
            LJMP NEXT

opFourPlus: MOV A, #4
            SJMP opXPlus
opTwoPlus:  MOV A, #2
            SJMP opXPlus
opOnePlus:  MOV A, #1
opXPlus:    ADD A, R7
            MOV R7, A
            MOV A, R6
            ADDC A, R6
            MOV R6, A
            CLR A
            ADDC A, R5
            MOV R5, A
            CLR A
            ADDC A, R4
            MOV R4, A
            LJMP NEXT

opSWAP:     MOV A, R4
            XCH A, N
            MOV R4, A
            MOV A, R5
            XCH A, N+1
            MOV R5, A
            MOV A, R6
            XCH A, N+2
            MOV R6, A
            MOV A, R7
            XCH A, N+3
            MOV R7, A
            LJMP NEXT

opSUB:      CLR C
            MOV A, N+3
            SUBB A, T+3
            MOV T+3, A
            MOV A, N+2
            SUBB A, T+2
            MOV T+2, A
            MOV A, N+1
            SUBB A, T+1
            MOV T+1, A
            MOV A, N
            SUBB A, T
            MOV T, A
            MOV CARRY, C
            LCALL SNIP
            LJMP NEXT

opJUMP:     MOV R0, #VPC
            LCALL GetIMM
            LJMP EX

FetchC:     ;r4r5r6r7 = VMmem[r4r5r6r7] 16-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROMC
            ADD A, #-RAMpages
            JNC FetchRAMC
            SJMP ClearT
FetchROMC:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            MOV R7, A
            CLR A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            RET
FetchRAMC:  MOV DPL, R7         ;RAM is page-aligned
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            MOV R7, A
            CLR A
            MOV R6, A
            MOV R5, A
            MOV R4, A
            RET

FetchW:     ;r4r5r6r7 = VMmem[r4r5r6r7] 16-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROMW
            ADD A, #-RAMpages
            JNC FetchRAMW
            SJMP ClearT
FetchROMW:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R7, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOV R5, A
            MOV R4, A
            RET
FetchRAMW:  MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            INC DPTR
            MOV R7, A
            MOVX A, @DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOV R5, A
            MOV R4, A
            RET

FetchL:     ;r4r5r6r7 = VMmem[r4r5r6r7] 32-bit
            MOV A, R6
            ADD A, #-ROMpages
            JNC FetchROML
            ADD A, #-RAMpages
            JNC FetchRAML
ClearT:     CLR A
            MOV R4, A
            MOV R5, A
            MOV R6, A
            MOV R7, A
            RET
FetchROML:  LCALL SetROMaddr
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R7, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R6, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R5, A
            CLR A
            MOVC A, @A+DPTR
            INC DPTR
            MOV R4, A
            RET
FetchRAML:  MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOVX A, @DPTR
            INC DPTR
            MOV R7, A
            MOVX A, @DPTR
            INC DPTR
            MOV R6, A
            MOVX A, @DPTR
            INC DPTR
            MOV R5, A
            MOVX A, @DPTR
            INC DPTR
            MOV R4, A
            RET
SetROMaddr: MOV A, R7
            ADD A, #-LOW(ROMsize)
            MOV A, R6
            ADD A, #-HIGH(ROMsize)
            JC SetROMbad
            MOV DPTR, #ROM      ;ROM is anywhere in code space
            MOV A, #HIGH(ROM)   ;Add T to get base address in DPTR
            ADD A, R7
            MOV DPL, A
            MOV A, #LOW(ROM)
            ADD A, R6
            MOV DPH, A
            RET
SetROMbad:  MOV DPTR, #ROM      ;bad address reads from beginning of ROM
            RET

opCstorePlus:                   ;VMmem[r4r5r6r7] = r7
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreCnone      ;can't store to ROM
            ADD A, #-RAMpages
            JNC StoreC
            SJMP StoreCnone
StoreC:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
StoreCnone: LJMP opOnePlus      ;nothing to store

opWstorePlus:                   ;VMmem[r4r5r6r7] = r7r6
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreWnone
            ADD A, #-RAMpages
            JNC StoreW
            SJMP StoreWnone
StoreW:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
StoreWnone: LJMP opTwoPlus

opStorePlus:                    ;VMmem[r4r5r6r7] = r7r6r5r4
            MOV A, R6
            ADD A, #-ROMpages
            JNC StoreLnone
            ADD A, #-RAMpages
            JNC StoreL
            SJMP StoreLnone
StoreL:     MOV DPL, R7
            MOV A, #HIGH(RAM)
            ADD A, R6
            MOV DPH, A
            MOV A, R7
            MOVX @DPTR, A
            INC DPTR
            MOV A, R6
            MOVX @DPTR, A
            INC DPTR
            MOV A, R5
            MOVX @DPTR, A
            INC DPTR
            MOV A, R4
            MOVX @DPTR, A
StoreLnone: LJMP opFourPlus

opCfetch:   LCALL FetchC
            LJMP NEXT
opCfetchPlus:
            LCALL SDUP
            LCALL FetchC
            MOV A, #1
            LCALL BumpN
            LJMP NEXT

opWfetch:   LCALL FetchW
            LJMP NEXT
opWfetchPlus:
            LCALL SDUP
            LCALL FetchW
            MOV A, #2
            LCALL BumpN
            LJMP NEXT

opFetch:    LCALL FetchL
            LJMP NEXT
opFetchPlus:
            LCALL SDUP
            LCALL FetchL
            MOV A, #4
            LCALL BumpN
            LJMP NEXT

opAND:      MOV A, R7
            ANL A, N+3
            MOV R7, A
            MOV A, R6
            ANL A, N+2
            MOV R6, A
            MOV A, R5
            ANL A, N+1
            MOV R5, A
            MOV A, R4
            ANL A, N
            MOV R4, A
            LCALL SNIP
            LJMP NEXT

opLitX:     ;T = (T<<24) | (IMM & 0xFFFFFF);
            MOV R0, #IR
            LCALL GetIMM
            MOV A, R7
            MOV R4, A
            MOV A, IR+1
            MOV R5, A
            MOV A, IR+2
            MOV R6, A
            MOV A, IR+3
            LJMP EX

opPUSH:     LCALL RDUPT
            LCALL SDROP         ;>r
            LJMP NEXT

opCALL:     LCALL PCTIMES2
            LCALL PCTIMES2
            MOV B, #VPC
            LCALL RDUP
            MOV R0, #VPC
            LCALL GetIMM
            LJMP EX

opXOR:      MOV A, R7
            XRL A, N+3
            MOV R7, A
            MOV A, R6
            XRL A, N+2
            MOV R6, A
            MOV A, R5
            XRL A, N+1
            MOV R5, A
            MOV A, R4
            XRL A, N
            MOV R4, A
            LCALL SNIP
            LJMP NEXT

opREPT:     CLR A
            MOV NEXTSLOT, A
            MOV SLOTID, A
            LJMP NEXT

opOVER:     MOV Scratch+0, N+0
            MOV Scratch+1, N+1
            MOV Scratch+2, N+2
            MOV Scratch+3, N+3
            LCALL SDUP
            MOV R4, Scratch+0
            MOV R5, Scratch+1
            MOV R6, Scratch+2
            MOV R7, Scratch+3
            LJMP NEXT

opTwoStarC: MOV C, CARRY
            SJMP opTwoStar1
opTwoStar:  CLR C
opTwoStar1: MOV A, R7
            RLC A
            MOV R7, A
            MOV A, R6
            RLC A
            MOV R6, A
            MOV A, R5
            RLC A
            MOV R5, A
            MOV A, R4
            RLC A
            MOV R4, A
            MOV CARRY, C
            LJMP NEXT


opMiREPT:   PUSH N+2
            MOV A, #1
            LCALL BumpN
            POP ACC
            RLC A
            JC opREPT
            LJMP NEXT

BumpN:      MOV R0, #N+3
BumpReg:    ADD A, @R0          ;Add A to [R0]
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            DEC R0
            CLR A
            ADDC A, @R0
            MOV @R0, A
            RET

opDROP:     LCALL SDROP
            LJMP NEXT

opUP:       MOV R0, #UP
            SJMP opXP
opRP:       MOV R0, #RP
            SJMP opXP
opSP:       MOV R0, #VSP
opXP:       MOV A, @R0          ;{T += (M + ROMsize)*4;}
            INC R0
            ADD A, #ROMpages    ;ROMsize/256
            MOV R2, A
            MOV A, @R0
            CLR C
            RLC A
            MOV R3, A           ;r2r3 = XP + ROMsize
            MOV A, R2
            RLC A
            MOV R2, A
            CLR C
            MOV A, R3
            RLC A
            MOV R3, A           ;r2r3 = (XP + ROMsize) << 2
            MOV A, R2
            RLC A
            MOV R2, A
            MOV A, R3
            ADD A, R7
            MOV R7, A
            MOV A, R2
            ADDC A, R6
            MOV R6, A
            CLR A
            ADDC A, R5
            MOV R5, A
            CLR A
            ADDC A, R4
            MOV R4, A
            LJMP NEXT


;not implemented
opStoreAS:
opFetchAS:  LJMP NEXT

opPORT:     MOV A, R4
            XCH A, DebugReg+0
            MOV R4, A
            MOV A, R5
            XCH A, DebugReg+0
            MOV R5, A
            MOV A, R6
            XCH A, DebugReg+0
            MOV R6, A
            MOV A, R7
            XCH A, DebugReg+0
            MOV R7, A
            LJMP NEXT

opLIT:      MOV R0, #IR
            LCALL GetIMM
            MOV R4, IR
            MOV R5, IR+1
            MOV R6, IR+2
            MOV R7, IR+3
            LJMP EX

TTOXP:      CLR C               ; r6r7 = (T>>2) & (RAMsize-1), assume RAMsize < 16K
            MOV A, R6
            RRC A
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
            CLR C
            MOV A, R6
            RRC A
            ANL A, #RAMpages-1
            MOV R6, A
            MOV A, R7
            RRC A
            MOV R7, A
            RET

opSetRP:    MOV B, #RP
            SJMP SetXP
opSetUP:    MOV B, #UP       ;UP = (T>>2) & (RAMsize-1);
SetXP:      LCALL TTOXP
            MOV R0, B
            MOV A, R6
            MOV @R0, A
            INC R0
            MOV A, R7
            MOV @R0, A
            LCALL SDROP
            LJMP NEXT

opSetSP:    LCALL TTOXP
            MOV R0, #VSP
            MOV A, R6
            MOV @R0, A
            INC R0
            MOV A, R7
            MOV @R0, A
            LJMP NEXT

opRfetch:   LCALL SDUP
            MOV B, #Scratch
            LCALL RDROP
            LJMP ScratchToTOS

; INDICES:

vmRegTable: DB T, 4, N, 4, RP, 2, VSP, 2, UP, 2, VPC, 4
;index         0     1     2      3       4      5

_vmRegRead: ;T,N,RP,SP,UP,PC    ;uint32_t vmRegRead(int id);
            MOV R0, #Scratch
            CLR A
            MOV R3, #4
clearscr:       MOV @R0, A              ;clear Scratch
                DJNZ R3, clearscr
            MOV DPTR, #vmRegTable
            MOV A, R7
            CLR C
            RLC A
            MOVC A, @A+DPTR             ;register IRAM address
            MOV R1, A                   ;source
            MOV A, R7
            CLR C
            RLC A
            INC A
            MOVC A, @A+DPTR             ;bytes to read
            MOV R3, A                   ;length
            CPL A
            INC A
            ADD A, #Scratch+4
            MOV R0, A                   ;destination
readreg:        MOV A, @R1
                INC R1
                MOV @R0, A
                INC R0
                DJNZ R3, readreg        ;copy reg to scratch
            MOV A, R7
            ADD A, #-2
            JNC vmRegPlain
            MOV R2, #2
shiftsreg:  MOV R3, #4                  ;if ID>2, multiply by 4
                MOV R0, #Scratch+4
                CLR C
shiftreg:           DEC R0
                    MOV A, @R0
                    RLC A
                    MOV @R0, A
                    DJNZ R3, shiftreg
                DJNZ R2, shiftsreg
                MOV A, R7
                ADD A, #-5
                JC vmRegPlain           ;RP, SP, UP need offset
                MOV A, Scratch+2
                ADD A, #LOW(RAMbase);
                MOV Scratch+2, A
                MOV A, Scratch+1
                ADDC A, #HIGH(RAMbase);
                MOV Scratch+1, A
vmRegPlain: MOV R4, Scratch+0
            MOV R5, Scratch+1
            MOV R6, Scratch+2
            MOV R7, Scratch+3
            RET

ROM:`12`

END
